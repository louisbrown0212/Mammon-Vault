{
  "address": "0xd46eD43509Dd67683f2B756C254445670f0ff565",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IVault",
          "name": "vault",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "PoolCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "weights",
          "type": "uint256[]"
        },
        {
          "internalType": "address[]",
          "name": "assetManagers",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "swapFeePercentage",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "swapEnabledOnStart",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "mustAllowlistLPs",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "managementSwapFeePercentage",
          "type": "uint256"
        }
      ],
      "name": "create",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCreationCode",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCreationCodeContracts",
      "outputs": [
        {
          "internalType": "address",
          "name": "contractA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "contractB",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPauseConfiguration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "pauseWindowDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bufferPeriodDuration",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVault",
      "outputs": [
        {
          "internalType": "contract IVault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "isPoolFromFactory",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xcfccba62d52a16c115151330f9be4394217506d949301543aa05822ff3e59fcf",
  "receipt": {
    "to": null,
    "from": "0xca8208694cC5CF50aB48Cd6B4b7b0F05FFc80928",
    "contractAddress": "0xd46eD43509Dd67683f2B756C254445670f0ff565",
    "transactionIndex": 4,
    "gasUsed": "6895297",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7b48569b4f9b1e0792583791c35060117b1184b9c38b9ff8a2333b397d312bba",
    "transactionHash": "0xcfccba62d52a16c115151330f9be4394217506d949301543aa05822ff3e59fcf",
    "logs": [],
    "blockNumber": 29465773,
    "cumulativeGasUsed": "7381356",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
  ],
  "solcInputHash": "2acb5fbbb67915dc01c38a0274eae461",
  "metadata": "{\"compiler\":{\"version\":\"0.8.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"assetManagers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"swapEnabledOnStart\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mustAllowlistLPs\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"managementSwapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreationCodeContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseConfiguration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pauseWindowDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolFromFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"create(string,string,address[],uint256[],address[],uint256,address,bool,bool,uint256)\":{\"params\":{\"assetManagers\":\"Addresses of asset managers.\",\"managementSwapFeePercentage\":\"Management swap fee percentage.\",\"mustAllowlistLPs\":\"If true, only listed addresses can join the pool.\",\"name\":\"Pool Token name.\",\"owner\":\"Pool controller.\",\"swapEnabledOnStart\":\"Swap enabled states on start.\",\"swapFeePercentage\":\"Swap fee percentage.\",\"symbol\":\"Pool Token symbol.\",\"tokens\":\"Addresses of asset tokens.\",\"weights\":\"Initial weights of asset tokens.\"}},\"getCreationCode()\":{\"details\":\"Returns the creation code of the contract this factory creates.\"},\"getCreationCodeContracts()\":{\"details\":\"Returns the two addresses where the creation code of the contract crated by this factory is stored.\"},\"getPauseConfiguration()\":{\"details\":\"Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this factory. `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable.\"},\"getVault()\":{\"details\":\"Returns the Vault's address.\"},\"isPoolFromFactory(address)\":{\"details\":\"Returns true if `pool` was created by this factory.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"create(string,string,address[],uint256[],address[],uint256,address,bool,bool,uint256)\":{\"notice\":\"Deploys a New Balancer ManagedPool.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MammonPoolFactoryV1.sol\":\"MammonPoolFactoryV1\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":9999},\"remappings\":[]},\"sources\":{\"contracts/MammonPoolFactoryV1.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./dependencies/balancer-labs/vault/contracts/interfaces/IVault.sol\\\";\\n\\nimport \\\"./dependencies/balancer-labs/pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol\\\";\\nimport \\\"./dependencies/balancer-labs/pool-utils/contracts/factories/FactoryWidePauseWindow.sol\\\";\\n\\nimport \\\"./dependencies/balancer-labs/pool-weighted/contracts/smart/ManagedPool.sol\\\";\\n\\ncontract MammonPoolFactoryV1 is\\n    BasePoolSplitCodeFactory,\\n    FactoryWidePauseWindow\\n{\\n    constructor(IVault vault)\\n        BasePoolSplitCodeFactory(vault, type(ManagedPool).creationCode)\\n    {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /// @notice Deploys a New Balancer ManagedPool.\\n    /// @param name Pool Token name.\\n    /// @param symbol Pool Token symbol.\\n    /// @param tokens Addresses of asset tokens.\\n    /// @param weights Initial weights of asset tokens.\\n    /// @param assetManagers Addresses of asset managers.\\n    /// @param swapFeePercentage Swap fee percentage.\\n    /// @param owner Pool controller.\\n    /// @param swapEnabledOnStart Swap enabled states on start.\\n    /// @param mustAllowlistLPs If true, only listed addresses can join the pool.\\n    /// @param managementSwapFeePercentage Management swap fee percentage.\\n    function create(\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        uint256[] memory weights,\\n        address[] memory assetManagers,\\n        uint256 swapFeePercentage,\\n        address owner,\\n        bool swapEnabledOnStart,\\n        bool mustAllowlistLPs,\\n        uint256 managementSwapFeePercentage\\n    ) external returns (address) {\\n        (\\n            uint256 pauseWindowDuration,\\n            uint256 bufferPeriodDuration\\n        ) = getPauseConfiguration();\\n\\n        return\\n            _create(\\n                abi.encode(\\n                    ManagedPool.NewPoolParams({\\n                        vault: getVault(),\\n                        name: name,\\n                        symbol: symbol,\\n                        tokens: tokens,\\n                        normalizedWeights: weights,\\n                        assetManagers: assetManagers,\\n                        swapFeePercentage: swapFeePercentage,\\n                        pauseWindowDuration: pauseWindowDuration,\\n                        bufferPeriodDuration: bufferPeriodDuration,\\n                        owner: owner,\\n                        swapEnabledOnStart: swapEnabledOnStart,\\n                        mustAllowlistLPs: mustAllowlistLPs,\\n                        managementSwapFeePercentage: managementSwapFeePercentage\\n                    })\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3cf2a2bcdfd58ca52e435e3f5c1558b57c9e0ceaf9c02d75cec94a5545ffc899\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/asset-manager-utils/contracts/IAssetManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\ninterface IAssetManager {\\n    /**\\n     * @notice Emitted when asset manager is rebalanced\\n     */\\n    event Rebalance(bytes32 poolId);\\n\\n    /**\\n     * @notice Sets the config\\n     */\\n    function setConfig(bytes32 poolId, bytes calldata config) external;\\n\\n    /**\\n     * Note: No function to read the asset manager config is included in IAssetManager\\n     * as the signature is expected to vary between asset manager implementations\\n     */\\n\\n    /**\\n     * @notice Returns the asset manager's token\\n     */\\n    function getToken() external view returns (IERC20);\\n\\n    /**\\n     * @return the current assets under management of this asset manager\\n     */\\n    function getAUM(bytes32 poolId) external view returns (uint256);\\n\\n    /**\\n     * @return poolCash - The up-to-date cash balance of the pool\\n     * @return poolManaged - The up-to-date managed balance of the pool\\n     */\\n    function getPoolBalances(bytes32 poolId) external view returns (uint256 poolCash, uint256 poolManaged);\\n\\n    /**\\n     * @return The difference in tokens between the target investment\\n     * and the currently invested amount (i.e. the amount that can be invested)\\n     */\\n    function maxInvestableBalance(bytes32 poolId) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the Vault on the value of the pool's investment returns\\n     */\\n    function updateBalanceOfPool(bytes32 poolId) external;\\n\\n    /**\\n     * @notice Determines whether the pool should rebalance given the provided balances\\n     */\\n    function shouldRebalance(uint256 cash, uint256 managed) external view returns (bool);\\n\\n    /**\\n     * @notice Rebalances funds between the pool and the asset manager to maintain target investment percentage.\\n     * @param poolId - the poolId of the pool to be rebalanced\\n     * @param force - a boolean representing whether a rebalance should be forced even when the pool is near balance\\n     */\\n    function rebalance(bytes32 poolId, bool force) external;\\n\\n    /**\\n     * @notice allows an authorized rebalancer to remove capital to facilitate large withdrawals\\n     * @param poolId - the poolId of the pool to withdraw funds back to\\n     * @param amount - the amount of tokens to withdraw back to the pool\\n     */\\n    function capitalOut(bytes32 poolId, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x3e3836d125a341cb3306f516da3ff28eb861895a70dbea199cb89e905b664387\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-utils/contracts/BalancerPoolToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../solidity-utils/contracts/openzeppelin/ERC20Permit.sol\\\";\\nimport \\\"../../vault/contracts/interfaces/IVault.sol\\\";\\n\\n/**\\n * @title Highly opinionated token implementation\\n * @author Balancer Labs\\n * @dev\\n * - Includes functions to increase and decrease allowance as a workaround\\n *   for the well-known issue with `approve`:\\n *   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n * - Allows for 'infinite allowance', where an allowance of 0xff..ff is not\\n *   decreased by calls to transferFrom\\n * - Lets a token holder use `transferFrom` to send their own tokens,\\n *   without first setting allowance\\n * - Emits 'Approval' events whenever allowance is changed by `transferFrom`\\n * - Assigns infinite allowance for all token holders to the Vault\\n */\\ncontract BalancerPoolToken is ERC20Permit {\\n    IVault private immutable _vault;\\n\\n    constructor(\\n        string memory tokenName,\\n        string memory tokenSymbol,\\n        IVault vault\\n    ) ERC20(tokenName, tokenSymbol) ERC20Permit(tokenName) {\\n        _vault = vault;\\n    }\\n\\n    function getVault() public view returns (IVault) {\\n        return _vault;\\n    }\\n\\n    // Overrides\\n\\n    /**\\n     * @dev Override to grant the Vault infinite allowance, causing for Pool Tokens to not require approval.\\n     *\\n     * This is sound as the Vault already provides authorization mechanisms when initiation token transfers, which this\\n     * contract inherits.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        if (spender == address(getVault())) {\\n            return uint256(-1);\\n        } else {\\n            return super.allowance(owner, spender);\\n        }\\n    }\\n\\n    /**\\n     * @dev Override to allow for 'infinite allowance' and let the token owner use `transferFrom` with no self-allowance\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        uint256 currentAllowance = allowance(sender, msg.sender);\\n        _require(msg.sender == sender || currentAllowance >= amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE);\\n\\n        _transfer(sender, recipient, amount);\\n\\n        if (msg.sender != sender && currentAllowance != uint256(-1)) {\\n            // Because of the previous require, we know that if msg.sender != sender then currentAllowance >= amount\\n            _approve(sender, msg.sender, currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Override to allow decreasing allowance by more than the current amount (setting it to zero)\\n     */\\n    function decreaseAllowance(address spender, uint256 amount) public override returns (bool) {\\n        uint256 currentAllowance = allowance(msg.sender, spender);\\n\\n        if (amount >= currentAllowance) {\\n            _approve(msg.sender, spender, 0);\\n        } else {\\n            // No risk of underflow due to if condition\\n            _approve(msg.sender, spender, currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    // Internal functions\\n\\n    function _mintPoolTokens(address recipient, uint256 amount) internal {\\n        _mint(recipient, amount);\\n    }\\n\\n    function _burnPoolTokens(address sender, uint256 amount) internal {\\n        _burn(sender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcfb49f9e3231a263dd25ae3e413deeceb2b2050bc19a63fc7f9b74b984b249e5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-utils/contracts/BaseMinimalSwapInfoPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BasePool.sol\\\";\\nimport \\\"../../vault/contracts/interfaces/IMinimalSwapInfoPool.sol\\\";\\n\\n/**\\n * @dev Extension of `BasePool`, adding a handler for `IMinimalSwapInfoPool.onSwap`.\\n *\\n * Derived contracts must call `BasePool`'s constructor, and implement `_onSwapGivenIn` and `_onSwapGivenOut` along with\\n * `BasePool`'s virtual functions. Inheriting from this contract lets derived contracts choose the Two Token or Minimal\\n * Swap Info specialization settings.\\n */\\nabstract contract BaseMinimalSwapInfoPool is IMinimalSwapInfoPool, BasePool {\\n    // Swap Hooks\\n\\n    function onSwap(\\n        SwapRequest memory request,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\\n        uint256 scalingFactorTokenIn = _scalingFactor(request.tokenIn);\\n        uint256 scalingFactorTokenOut = _scalingFactor(request.tokenOut);\\n\\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\\n            // Fees are subtracted before scaling, to reduce the complexity of the rounding direction analysis.\\n            uint256 amountInMinusSwapFees = _subtractSwapFeeAmount(request.amount);\\n\\n            // Process the (upscaled!) swap fee.\\n            uint256 swapFee = request.amount - amountInMinusSwapFees;\\n            _processSwapFeeAmount(request.tokenIn, _upscale(swapFee, scalingFactorTokenIn));\\n\\n            request.amount = amountInMinusSwapFees;\\n\\n            // All token amounts are upscaled.\\n            balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\\n            balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\\n            request.amount = _upscale(request.amount, scalingFactorTokenIn);\\n\\n            uint256 amountOut = _onSwapGivenIn(request, balanceTokenIn, balanceTokenOut);\\n\\n            // amountOut tokens are exiting the Pool, so we round down.\\n            return _downscaleDown(amountOut, scalingFactorTokenOut);\\n        } else {\\n            // All token amounts are upscaled.\\n            balanceTokenIn = _upscale(balanceTokenIn, scalingFactorTokenIn);\\n            balanceTokenOut = _upscale(balanceTokenOut, scalingFactorTokenOut);\\n            request.amount = _upscale(request.amount, scalingFactorTokenOut);\\n\\n            uint256 amountIn = _onSwapGivenOut(request, balanceTokenIn, balanceTokenOut);\\n\\n            // amountIn tokens are entering the Pool, so we round up.\\n            amountIn = _downscaleUp(amountIn, scalingFactorTokenIn);\\n\\n            // Fees are added after scaling happens, to reduce the complexity of the rounding direction analysis.\\n            uint256 amountInPlusSwapFees = _addSwapFeeAmount(amountIn);\\n\\n            // Process the (upscaled!) swap fee.\\n            uint256 swapFee = amountInPlusSwapFees - amountIn;\\n            _processSwapFeeAmount(request.tokenIn, _upscale(swapFee, scalingFactorTokenIn));\\n\\n            return amountInPlusSwapFees;\\n        }\\n    }\\n\\n    /*\\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens entering the Pool is known.\\n     *\\n     * Returns the amount of tokens that will be taken from the Pool in return.\\n     *\\n     * All amounts inside `swapRequest`, `balanceTokenIn` and `balanceTokenOut` are upscaled. The swap fee has already\\n     * been deducted from `swapRequest.amount`.\\n     *\\n     * The return value is also considered upscaled, and will be downscaled (rounding down) before returning it to the\\n     * Vault.\\n     */\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) internal virtual returns (uint256);\\n\\n    /*\\n     * @dev Called when a swap with the Pool occurs, where the amount of tokens exiting the Pool is known.\\n     *\\n     * Returns the amount of tokens that will be granted to the Pool in return.\\n     *\\n     * All amounts inside `swapRequest`, `balanceTokenIn` and `balanceTokenOut` are upscaled.\\n     *\\n     * The return value is also considered upscaled, and will be downscaled (rounding up) before applying the swap fee\\n     * and returning it to the Vault.\\n     */\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256 balanceTokenIn,\\n        uint256 balanceTokenOut\\n    ) internal virtual returns (uint256);\\n\\n    /**\\n     * @dev Called whenever a swap fee is charged. Implementations should call their parents via super, to ensure all\\n     * implementations in the inheritance tree are called.\\n     *\\n     * Callers must call one of the three `_processSwapFeeAmount` functions when swap fees are computed,\\n     * and upscale `amount`.\\n     */\\n    function _processSwapFeeAmount(\\n        uint256, /*index*/\\n        uint256 /*amount*/\\n    ) internal virtual {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function _processSwapFeeAmount(IERC20 token, uint256 amount) internal {\\n        _processSwapFeeAmount(_tokenAddressToIndex(token), amount);\\n    }\\n\\n    function _processSwapFeeAmounts(uint256[] memory amounts) internal {\\n        InputHelpers.ensureInputLengthMatch(amounts.length, _getTotalTokens());\\n\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            _processSwapFeeAmount(i, amounts[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the index of `token` in the Pool's token array (i.e. the one `vault.getPoolTokens()` would return).\\n     *\\n     * A trivial (and incorrect!) implementation is already provided for Pools that don't override\\n     * `_processSwapFeeAmount` and skip the entire feature. However, Pools that do override `_processSwapFeeAmount`\\n     * *must* override this function with a meaningful implementation.\\n     */\\n    function _tokenAddressToIndex(\\n        IERC20 /*token*/\\n    ) internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x70e05f2abb71a84614aac3101e72fc549f35694f03ce7c8211cbe519cf9fafa3\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-utils/contracts/BasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../solidity-utils/contracts/math/Math.sol\\\";\\nimport \\\"../../solidity-utils/contracts/math/FixedPoint.sol\\\";\\nimport \\\"../../solidity-utils/contracts/helpers/InputHelpers.sol\\\";\\nimport \\\"../../solidity-utils/contracts/helpers/TemporarilyPausable.sol\\\";\\nimport \\\"../../solidity-utils/contracts/helpers/WordCodec.sol\\\";\\nimport \\\"../../solidity-utils/contracts/openzeppelin/ERC20.sol\\\";\\n\\nimport \\\"../../vault/contracts/interfaces/IVault.sol\\\";\\nimport \\\"../../vault/contracts/interfaces/IBasePool.sol\\\";\\n\\nimport \\\"../../asset-manager-utils/contracts/IAssetManager.sol\\\";\\n\\nimport \\\"./BalancerPoolToken.sol\\\";\\nimport \\\"./BasePoolAuthorization.sol\\\";\\n\\n// solhint-disable max-states-count\\n\\n/**\\n * @dev Reference implementation for the base layer of a Pool contract that manages a single Pool with optional\\n * Asset Managers, an admin-controlled swap fee percentage, and an emergency pause mechanism.\\n *\\n * Note that neither swap fees nor the pause mechanism are used by this contract. They are passed through so that\\n * derived contracts can use them via the `_addSwapFeeAmount` and `_subtractSwapFeeAmount` functions, and the\\n * `whenNotPaused` modifier.\\n *\\n * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.\\n *\\n * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from\\n * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces\\n * and implement the swap callbacks themselves.\\n */\\nabstract contract BasePool is IBasePool, BasePoolAuthorization, BalancerPoolToken, TemporarilyPausable {\\n    using WordCodec for bytes32;\\n    using FixedPoint for uint256;\\n\\n    uint256 private constant _MIN_TOKENS = 2;\\n\\n    uint256 private constant _DEFAULT_MINIMUM_BPT = 1e6;\\n\\n    // 1e18 corresponds to 1.0, or a 100% fee\\n    uint256 private constant _MIN_SWAP_FEE_PERCENTAGE = 1e12; // 0.0001%\\n    uint256 private constant _MAX_SWAP_FEE_PERCENTAGE = 1e17; // 10% - this fits in 64 bits\\n\\n    // Storage slot that can be used to store unrelated pieces of information. In particular, by default is used\\n    // to store only the swap fee percentage of a pool. But it can be extended to store some more pieces of information.\\n    // The swap fee percentage is stored in the most-significant 64 bits, therefore the remaining 192 bits can be\\n    // used to store any other piece of information.\\n    bytes32 private _miscData;\\n    uint256 private constant _SWAP_FEE_PERCENTAGE_OFFSET = 192;\\n\\n    bytes32 private immutable _poolId;\\n\\n    event SwapFeePercentageChanged(uint256 swapFeePercentage);\\n\\n    constructor(\\n        IVault vault,\\n        IVault.PoolSpecialization specialization,\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers,\\n        uint256 swapFeePercentage,\\n        uint256 pauseWindowDuration,\\n        uint256 bufferPeriodDuration,\\n        address owner\\n    )\\n        // Base Pools are expected to be deployed using factories. By using the factory address as the action\\n        // disambiguator, we make all Pools deployed by the same factory share action identifiers. This allows for\\n        // simpler management of permissions (such as being able to manage granting the 'set fee percentage' action in\\n        // any Pool created by the same factory), while still making action identifiers unique among different factories\\n        // if the selectors match, preventing accidental errors.\\n        Authentication(bytes32(uint256(msg.sender)))\\n        BalancerPoolToken(name, symbol, vault)\\n        BasePoolAuthorization(owner)\\n        TemporarilyPausable(pauseWindowDuration, bufferPeriodDuration)\\n    {\\n        _require(tokens.length >= _MIN_TOKENS, Errors.MIN_TOKENS);\\n        _require(tokens.length <= _getMaxTokens(), Errors.MAX_TOKENS);\\n\\n        // The Vault only requires the token list to be ordered for the Two Token Pools specialization. However,\\n        // to make the developer experience consistent, we are requiring this condition for all the native pools.\\n        // Also, since these Pools will register tokens only once, we can ensure the Pool tokens will follow the same\\n        // order. We rely on this property to make Pools simpler to write, as it lets us assume that the\\n        // order of token-specific parameters (such as token weights) will not change.\\n        InputHelpers.ensureArrayIsSorted(tokens);\\n\\n        _setSwapFeePercentage(swapFeePercentage);\\n\\n        bytes32 poolId = vault.registerPool(specialization);\\n\\n        vault.registerTokens(poolId, tokens, assetManagers);\\n\\n        // Set immutable state variables - these cannot be read from during construction\\n        _poolId = poolId;\\n    }\\n\\n    // Getters / Setters\\n\\n    function getPoolId() public view override returns (bytes32) {\\n        return _poolId;\\n    }\\n\\n    function _getTotalTokens() internal view virtual returns (uint256);\\n\\n    function _getMaxTokens() internal pure virtual returns (uint256);\\n\\n    /**\\n     * @dev Returns the minimum BPT supply. This amount is minted to the zero address during initialization, effectively\\n     * locking it.\\n     *\\n     * This is useful to make sure Pool initialization happens only once, but derived Pools can change this value (even\\n     * to zero) by overriding this function.\\n     */\\n    function _getMinimumBpt() internal pure virtual returns (uint256) {\\n        return _DEFAULT_MINIMUM_BPT;\\n    }\\n\\n    function getSwapFeePercentage() public view returns (uint256) {\\n        return _miscData.decodeUint64(_SWAP_FEE_PERCENTAGE_OFFSET);\\n    }\\n\\n    function setSwapFeePercentage(uint256 swapFeePercentage) public virtual authenticate whenNotPaused {\\n        _setSwapFeePercentage(swapFeePercentage);\\n    }\\n\\n    function _setSwapFeePercentage(uint256 swapFeePercentage) private {\\n        _require(swapFeePercentage >= _MIN_SWAP_FEE_PERCENTAGE, Errors.MIN_SWAP_FEE_PERCENTAGE);\\n        _require(swapFeePercentage <= _MAX_SWAP_FEE_PERCENTAGE, Errors.MAX_SWAP_FEE_PERCENTAGE);\\n\\n        _miscData = _miscData.insertUint64(swapFeePercentage, _SWAP_FEE_PERCENTAGE_OFFSET);\\n        emit SwapFeePercentageChanged(swapFeePercentage);\\n    }\\n\\n    function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\\n        public\\n        virtual\\n        authenticate\\n        whenNotPaused\\n    {\\n        _setAssetManagerPoolConfig(token, poolConfig);\\n    }\\n\\n    function _setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig) private {\\n        bytes32 poolId = getPoolId();\\n        (, , , address assetManager) = getVault().getPoolTokenInfo(poolId, token);\\n\\n        IAssetManager(assetManager).setConfig(poolId, poolConfig);\\n    }\\n\\n    function setPaused(bool paused) external authenticate {\\n        _setPaused(paused);\\n    }\\n\\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual override returns (bool) {\\n        return\\n            (actionId == getActionId(this.setSwapFeePercentage.selector)) ||\\n            (actionId == getActionId(this.setAssetManagerPoolConfig.selector));\\n    }\\n\\n    function _getMiscData() internal view returns (bytes32) {\\n        return _miscData;\\n    }\\n\\n    /**\\n     * Inserts data into the least-significant 192 bits of the misc data storage slot.\\n     * Note that the remaining 64 bits are used for the swap fee percentage and cannot be overloaded.\\n     */\\n    function _setMiscData(bytes32 newData) internal {\\n        _miscData = _miscData.insertBits192(newData, 0);\\n    }\\n\\n    // Join / Exit Hooks\\n\\n    modifier onlyVault(bytes32 poolId) {\\n        _require(msg.sender == address(getVault()), Errors.CALLER_NOT_VAULT);\\n        _require(poolId == getPoolId(), Errors.INVALID_POOL_ID);\\n        _;\\n    }\\n\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory scalingFactors = _scalingFactors();\\n\\n        if (totalSupply() == 0) {\\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\\n                poolId,\\n                sender,\\n                recipient,\\n                scalingFactors,\\n                userData\\n            );\\n\\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\\n            // Pool from ever being fully drained.\\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\\n            _mintPoolTokens(address(0), _getMinimumBpt());\\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\\n\\n            // amountsIn are amounts entering the Pool, so we round up.\\n            _downscaleUpArray(amountsIn, scalingFactors);\\n\\n            return (amountsIn, new uint256[](_getTotalTokens()));\\n        } else {\\n            _upscaleArray(balances, scalingFactors);\\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\\n                poolId,\\n                sender,\\n                recipient,\\n                balances,\\n                lastChangeBlock,\\n                protocolSwapFeePercentage,\\n                scalingFactors,\\n                userData\\n            );\\n\\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\\n\\n            _mintPoolTokens(recipient, bptAmountOut);\\n\\n            // amountsIn are amounts entering the Pool, so we round up.\\n            _downscaleUpArray(amountsIn, scalingFactors);\\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\\n\\n            return (amountsIn, dueProtocolFeeAmounts);\\n        }\\n    }\\n\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory scalingFactors = _scalingFactors();\\n        _upscaleArray(balances, scalingFactors);\\n\\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            scalingFactors,\\n            userData\\n        );\\n\\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\\n\\n        _burnPoolTokens(sender, bptAmountIn);\\n\\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\\n        _downscaleDownArray(amountsOut, scalingFactors);\\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\\n\\n        return (amountsOut, dueProtocolFeeAmounts);\\n    }\\n\\n    // Query functions\\n\\n    /**\\n     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the\\n     * Vault with the same arguments, along with the number of tokens `sender` would have to supply.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee percentage and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n    function queryJoin(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\\n\\n        _queryAction(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            userData,\\n            _onJoinPool,\\n            _downscaleUpArray\\n        );\\n\\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\\n        // and we don't need to return anything here - it just silences compiler warnings.\\n        return (bptOut, amountsIn);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee percentage and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n    function queryExit(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\\n\\n        _queryAction(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            lastChangeBlock,\\n            protocolSwapFeePercentage,\\n            userData,\\n            _onExitPool,\\n            _downscaleDownArray\\n        );\\n\\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\\n        // and we don't need to return anything here - it just silences compiler warnings.\\n        return (bptIn, amountsOut);\\n    }\\n\\n    // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are\\n    // upscaled.\\n\\n    /**\\n     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.\\n     *\\n     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.\\n     *\\n     * Minted BPT will be sent to `recipient`, except for _getMinimumBpt(), which will be deducted from this amount and\\n     * sent to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP\\n     * from ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire\\n     * Pool's lifetime.\\n     *\\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\\n     * be downscaled (rounding up) before being returned to the Vault.\\n     */\\n    function _onInitializePool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);\\n\\n    /**\\n     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).\\n     *\\n     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of\\n     * tokens to pay in protocol swap fees.\\n     *\\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\\n     *\\n     * Minted BPT will be sent to `recipient`.\\n     *\\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\\n     * be downscaled (rounding up) before being returned to the Vault.\\n     *\\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These\\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\\n     */\\n    function _onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        returns (\\n            uint256 bptAmountOut,\\n            uint256[] memory amountsIn,\\n            uint256[] memory dueProtocolFeeAmounts\\n        );\\n\\n    /**\\n     * @dev Called whenever the Pool is exited.\\n     *\\n     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and\\n     * the number of tokens to pay in protocol swap fees.\\n     *\\n     * Implementations of this function might choose to mutate the `balances` array to save gas (e.g. when\\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\\n     *\\n     * BPT will be burnt from `sender`.\\n     *\\n     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will be downscaled\\n     * (rounding down) before being returned to the Vault.\\n     *\\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These\\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\\n     */\\n    function _onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        returns (\\n            uint256 bptAmountIn,\\n            uint256[] memory amountsOut,\\n            uint256[] memory dueProtocolFeeAmounts\\n        );\\n\\n    // Internal functions\\n\\n    /**\\n     * @dev Adds swap fee amount to `amount`, returning a higher value.\\n     */\\n    function _addSwapFeeAmount(uint256 amount) internal view returns (uint256) {\\n        // This returns amount + fee amount, so we round up (favoring a higher fee amount).\\n        return amount.divUp(FixedPoint.ONE.sub(getSwapFeePercentage()));\\n    }\\n\\n    /**\\n     * @dev Subtracts swap fee amount from `amount`, returning a lower value.\\n     */\\n    function _subtractSwapFeeAmount(uint256 amount) internal view returns (uint256) {\\n        // This returns amount - fee amount, so we round up (favoring a higher fee amount).\\n        uint256 feeAmount = amount.mulUp(getSwapFeePercentage());\\n        return amount.sub(feeAmount);\\n    }\\n\\n    // Scaling\\n\\n    /**\\n     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\\n     * it had 18 decimals.\\n     */\\n    function _computeScalingFactor(IERC20 token) internal view returns (uint256) {\\n        if (address(token) == address(this)) {\\n            return FixedPoint.ONE;\\n        }\\n\\n        // Tokens that don't implement the `decimals` method are not supported.\\n        uint256 tokenDecimals = ERC20(address(token)).decimals();\\n\\n        // Tokens with more than 18 decimals are not supported.\\n        uint256 decimalsDifference = Math.sub(18, tokenDecimals);\\n        return FixedPoint.ONE * 10**decimalsDifference;\\n    }\\n\\n    /**\\n     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the\\n     * Pool.\\n     *\\n     * All scaling factors are fixed-point values with 18 decimals, to allow for this function to be overridden by\\n     * derived contracts that need to apply further scaling, making these factors potentially non-integer.\\n     *\\n     * The largest 'base' scaling factor (i.e. in tokens with less than 18 decimals) is 10**18, which in fixed-point is\\n     * 10**36. This value can be multiplied with a 112 bit Vault balance with no overflow by a factor of ~1e7, making\\n     * even relatively 'large' factors safe to use.\\n     *\\n     * The 1e7 figure is the result of 2**256 / (1e18 * 1e18 * 2**112).\\n     */\\n    function _scalingFactor(IERC20 token) internal view virtual returns (uint256);\\n\\n    /**\\n     * @dev Same as `_scalingFactor()`, except for all registered tokens (in the same order as registered). The Vault\\n     * will always pass balances in this order when calling any of the Pool hooks.\\n     */\\n    function _scalingFactors() internal view virtual returns (uint256[] memory);\\n\\n    function getScalingFactors() external view returns (uint256[] memory) {\\n        return _scalingFactors();\\n    }\\n\\n    /**\\n     * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\\n     * scaling or not.\\n     */\\n    function _upscale(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        // Upscale rounding wouldn't necessarily always go in the same direction: in a swap for example the balance of\\n        // token in should be rounded up, and that of token out rounded down. This is the only place where we round in\\n        // the same direction for all amounts, as the impact of this rounding is expected to be minimal (and there's no\\n        // rounding error unless `_scalingFactor()` is overriden).\\n        return FixedPoint.mulDown(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*\\n     * the `amounts` array.\\n     */\\n    function _upscaleArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = FixedPoint.mulDown(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\\n     * whether it needed scaling or not. The result is rounded down.\\n     */\\n    function _downscaleDown(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return FixedPoint.divDown(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead\\n     * *mutates* the `amounts` array.\\n     */\\n    function _downscaleDownArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = FixedPoint.divDown(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\\n     * whether it needed scaling or not. The result is rounded up.\\n     */\\n    function _downscaleUp(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return FixedPoint.divUp(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead\\n     * *mutates* the `amounts` array.\\n     */\\n    function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = FixedPoint.divUp(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    function _getAuthorizer() internal view override returns (IAuthorizer) {\\n        // Access control management is delegated to the Vault's Authorizer. This lets Balancer Governance manage which\\n        // accounts can call permissioned functions: for example, to perform emergency pauses.\\n        // If the owner is delegated, then *all* permissioned functions, including `setSwapFeePercentage`, will be under\\n        // Governance control.\\n        return getVault().getAuthorizer();\\n    }\\n\\n    function _queryAction(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData,\\n        function(bytes32, address, address, uint256[] memory, uint256, uint256, uint256[] memory, bytes memory)\\n            internal\\n            returns (uint256, uint256[] memory, uint256[] memory) _action,\\n        function(uint256[] memory, uint256[] memory) internal view _downscaleArray\\n    ) private {\\n        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed\\n        // explanation.\\n\\n        if (msg.sender != address(this)) {\\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\\n            // the preceding if statement will be executed instead.\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = address(this).call(msg.data);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // This call should always revert to decode the bpt and token amounts from the revert reason\\n                switch success\\n                    case 0 {\\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\\n                        // stored there as we take full control of the execution and then immediately return.\\n\\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\\n                        // there was another revert reason and we should forward it.\\n                        returndatacopy(0, 0, 0x04)\\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n\\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\\n                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {\\n                            returndatacopy(0, 0, returndatasize())\\n                            revert(0, returndatasize())\\n                        }\\n\\n                        // The returndata contains the signature, followed by the raw memory representation of the\\n                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded\\n                        // representation of these.\\n                        // An ABI-encoded response will include one additional field to indicate the starting offset of\\n                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the\\n                        // returndata.\\n                        //\\n                        // In returndata:\\n                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]\\n                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]\\n                        //\\n                        // We now need to return (ABI-encoded values):\\n                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]\\n                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]\\n\\n                        // We copy 32 bytes for the `bptAmount` from returndata into memory.\\n                        // Note that we skip the first 4 bytes for the error signature\\n                        returndatacopy(0, 0x04, 32)\\n\\n                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after\\n                        // the initial 64 bytes.\\n                        mstore(0x20, 64)\\n\\n                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.\\n                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also\\n                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.\\n                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))\\n\\n                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to\\n                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the\\n                        // error signature.\\n                        return(0, add(returndatasize(), 28))\\n                    }\\n                    default {\\n                        // This call should always revert, but we fail nonetheless if that didn't happen\\n                        invalid()\\n                    }\\n            }\\n        } else {\\n            uint256[] memory scalingFactors = _scalingFactors();\\n            _upscaleArray(balances, scalingFactors);\\n\\n            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _action(\\n                poolId,\\n                sender,\\n                recipient,\\n                balances,\\n                lastChangeBlock,\\n                protocolSwapFeePercentage,\\n                scalingFactors,\\n                userData\\n            );\\n\\n            _downscaleArray(tokenAmounts, scalingFactors);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of\\n                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values\\n                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32\\n                let size := mul(mload(tokenAmounts), 32)\\n\\n                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there\\n                // will be at least one available slot due to how the memory scratch space works.\\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\\n                let start := sub(tokenAmounts, 0x20)\\n                mstore(start, bptAmount)\\n\\n                // We send one extra value for the error signature \\\"QueryError(uint256,uint256[])\\\" which is 0x43adbafb\\n                // We use the previous slot to `bptAmount`.\\n                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)\\n                start := sub(start, 0x04)\\n\\n                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return\\n                // the `bptAmount`, the array 's length, and the error signature.\\n                revert(start, add(size, 68))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x85d9bc9d2d29e47942f4b2bde80468a3e5ee01c403376d035f9c85412c0a195f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-utils/contracts/BasePoolAuthorization.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../solidity-utils/contracts/helpers/Authentication.sol\\\";\\nimport \\\"../../vault/contracts/interfaces/IAuthorizer.sol\\\";\\n\\nimport \\\"./BasePool.sol\\\";\\n\\n/**\\n * @dev Base authorization layer implementation for Pools.\\n *\\n * The owner account can call some of the permissioned functions - access control of the rest is delegated to the\\n * Authorizer. Note that this owner is immutable: more sophisticated permission schemes, such as multiple ownership,\\n * granular roles, etc., could be built on top of this by making the owner a smart contract.\\n *\\n * Access control of all other permissioned functions is delegated to an Authorizer. It is also possible to delegate\\n * control of *all* permissioned functions to the Authorizer by setting the owner address to `_DELEGATE_OWNER`.\\n */\\nabstract contract BasePoolAuthorization is Authentication {\\n    address private immutable _owner;\\n\\n    address private constant _DELEGATE_OWNER = 0xBA1BA1ba1BA1bA1bA1Ba1BA1ba1BA1bA1ba1ba1B;\\n\\n    constructor(address owner) {\\n        _owner = owner;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function getAuthorizer() external view returns (IAuthorizer) {\\n        return _getAuthorizer();\\n    }\\n\\n    function _canPerform(bytes32 actionId, address account) internal view override returns (bool) {\\n        if ((getOwner() != _DELEGATE_OWNER) && _isOwnerOnlyAction(actionId)) {\\n            // Only the owner can perform \\\"owner only\\\" actions, unless the owner is delegated.\\n            return msg.sender == getOwner();\\n        } else {\\n            // Non-owner actions are always processed via the Authorizer, as \\\"owner only\\\" ones are when delegated.\\n            return _getAuthorizer().canPerform(actionId, account, address(this));\\n        }\\n    }\\n\\n    function _isOwnerOnlyAction(bytes32 actionId) internal view virtual returns (bool);\\n\\n    function _getAuthorizer() internal view virtual returns (IAuthorizer);\\n}\\n\",\"keccak256\":\"0x89833664e48e45d2092113c7fb4a4b1fc2b490f8690c1dd23a3045cbd6186701\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-utils/contracts/factories/BasePoolSplitCodeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../solidity-utils/contracts/helpers/BaseSplitCodeFactory.sol\\\";\\nimport \\\"../../../vault/contracts/interfaces/IVault.sol\\\";\\n\\n/**\\n * @dev Same as `BasePoolFactory`, for Pools whose creation code is so large that the factory cannot hold it.\\n */\\nabstract contract BasePoolSplitCodeFactory is BaseSplitCodeFactory {\\n    IVault private immutable _vault;\\n    mapping(address => bool) private _isPoolFromFactory;\\n\\n    event PoolCreated(address indexed pool);\\n\\n    constructor(IVault vault, bytes memory creationCode) BaseSplitCodeFactory(creationCode) {\\n        _vault = vault;\\n    }\\n\\n    /**\\n     * @dev Returns the Vault's address.\\n     */\\n    function getVault() public view returns (IVault) {\\n        return _vault;\\n    }\\n\\n    /**\\n     * @dev Returns true if `pool` was created by this factory.\\n     */\\n    function isPoolFromFactory(address pool) external view returns (bool) {\\n        return _isPoolFromFactory[pool];\\n    }\\n\\n    function _create(bytes memory constructorArgs) internal override returns (address) {\\n        address pool = super._create(constructorArgs);\\n\\n        _isPoolFromFactory[pool] = true;\\n        emit PoolCreated(pool);\\n\\n        return pool;\\n    }\\n}\\n\",\"keccak256\":\"0x3098ade4ce8b75b9beed0c87d1870488bd46a7c4d6d7b3ac85d4cf8ae32b5d49\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-utils/contracts/factories/FactoryWidePauseWindow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Utility to create Pool factories for Pools that use the `TemporarilyPausable` contract.\\n *\\n * By calling `TemporarilyPausable`'s constructor with the result of `getPauseConfiguration`, all Pools created by this\\n * factory will share the same Pause Window end time, after which both old and new Pools will not be pausable.\\n */\\ncontract FactoryWidePauseWindow {\\n    // This contract relies on timestamps in a similar way as `TemporarilyPausable` does - the same caveats apply.\\n    // solhint-disable not-rely-on-time\\n\\n    uint256 private constant _INITIAL_PAUSE_WINDOW_DURATION = 90 days;\\n    uint256 private constant _BUFFER_PERIOD_DURATION = 30 days;\\n\\n    // Time when the pause window for all created Pools expires, and the pause window duration of new Pools becomes\\n    // zero.\\n    uint256 private immutable _poolsPauseWindowEndTime;\\n\\n    constructor() {\\n        _poolsPauseWindowEndTime = block.timestamp + _INITIAL_PAUSE_WINDOW_DURATION;\\n    }\\n\\n    /**\\n     * @dev Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this\\n     * factory.\\n     *\\n     * `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and\\n     * `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable.\\n     */\\n    function getPauseConfiguration() public view returns (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\\n        uint256 currentTime = block.timestamp;\\n        if (currentTime < _poolsPauseWindowEndTime) {\\n            // The buffer period is always the same since its duration is related to how much time is needed to respond\\n            // to a potential emergency. The Pause Window duration however decreases as the end time approaches.\\n\\n            pauseWindowDuration = _poolsPauseWindowEndTime - currentTime; // No need for checked arithmetic.\\n            bufferPeriodDuration = _BUFFER_PERIOD_DURATION;\\n        } else {\\n            // After the end time, newly created Pools have no Pause Window, nor Buffer Period (since they are not\\n            // pausable in the first place).\\n\\n            pauseWindowDuration = 0;\\n            bufferPeriodDuration = 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d764b70fdb9f4d2b07f2914ff5deec66f1bc193741017afef2fa14be57dc4ef\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-weighted/contracts/BaseWeightedPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../solidity-utils/contracts/math/FixedPoint.sol\\\";\\nimport \\\"../../solidity-utils/contracts/helpers/InputHelpers.sol\\\";\\n\\nimport \\\"../../pool-utils/contracts/BaseMinimalSwapInfoPool.sol\\\";\\n\\nimport \\\"./WeightedPoolUserData.sol\\\";\\nimport \\\"./WeightedMath.sol\\\";\\n\\n/**\\n * @dev Base class for WeightedPools containing swap, join and exit logic, but leaving storage and management of\\n * the weights to subclasses. Derived contracts can choose to make weights immutable, mutable, or even dynamic\\n *  based on local or external logic.\\n */\\nabstract contract BaseWeightedPool is BaseMinimalSwapInfoPool {\\n    using FixedPoint for uint256;\\n    using WeightedPoolUserData for bytes;\\n\\n    uint256 private _lastInvariant;\\n\\n    constructor(\\n        IVault vault,\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers,\\n        uint256 swapFeePercentage,\\n        uint256 pauseWindowDuration,\\n        uint256 bufferPeriodDuration,\\n        address owner\\n    )\\n        BasePool(\\n            vault,\\n            // Given BaseMinimalSwapInfoPool supports both of these specializations, and this Pool never registers or\\n            // deregisters any tokens after construction, picking Two Token when the Pool only has two tokens is free\\n            // gas savings.\\n            tokens.length == 2 ? IVault.PoolSpecialization.TWO_TOKEN : IVault.PoolSpecialization.MINIMAL_SWAP_INFO,\\n            name,\\n            symbol,\\n            tokens,\\n            assetManagers,\\n            swapFeePercentage,\\n            pauseWindowDuration,\\n            bufferPeriodDuration,\\n            owner\\n        )\\n    {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    // Virtual functions\\n\\n    /**\\n     * @dev Returns the normalized weight of `token`. Weights are fixed point numbers that sum to FixedPoint.ONE.\\n     */\\n    function _getNormalizedWeight(IERC20 token) internal view virtual returns (uint256);\\n\\n    /**\\n     * @dev Returns all normalized weights, in the same order as the Pool's tokens.\\n     */\\n    function _getNormalizedWeights() internal view virtual returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns all normalized weights, in the same order as the Pool's tokens, along with the index of the token\\n     * with the highest weight.\\n     */\\n    function _getNormalizedWeightsAndMaxWeightIndex() internal view virtual returns (uint256[] memory, uint256);\\n\\n    function getLastInvariant() public view virtual returns (uint256) {\\n        return _lastInvariant;\\n    }\\n\\n    /**\\n     * @dev Returns the current value of the invariant.\\n     */\\n    function getInvariant() public view returns (uint256) {\\n        (, uint256[] memory balances, ) = getVault().getPoolTokens(getPoolId());\\n\\n        // Since the Pool hooks always work with upscaled balances, we manually\\n        // upscale here for consistency\\n        _upscaleArray(balances, _scalingFactors());\\n\\n        (uint256[] memory normalizedWeights, ) = _getNormalizedWeightsAndMaxWeightIndex();\\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\\n    }\\n\\n    function getNormalizedWeights() external view returns (uint256[] memory) {\\n        return _getNormalizedWeights();\\n    }\\n\\n    // Base Pool handlers\\n\\n    // Swap\\n\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) internal view virtual override whenNotPaused returns (uint256) {\\n        // Swaps are disabled while the contract is paused.\\n\\n        return\\n            WeightedMath._calcOutGivenIn(\\n                currentBalanceTokenIn,\\n                _getNormalizedWeight(swapRequest.tokenIn),\\n                currentBalanceTokenOut,\\n                _getNormalizedWeight(swapRequest.tokenOut),\\n                swapRequest.amount\\n            );\\n    }\\n\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) internal view virtual override whenNotPaused returns (uint256) {\\n        // Swaps are disabled while the contract is paused.\\n\\n        return\\n            WeightedMath._calcInGivenOut(\\n                currentBalanceTokenIn,\\n                _getNormalizedWeight(swapRequest.tokenIn),\\n                currentBalanceTokenOut,\\n                _getNormalizedWeight(swapRequest.tokenOut),\\n                swapRequest.amount\\n            );\\n    }\\n\\n    // Initialize\\n\\n    function _onInitializePool(\\n        bytes32,\\n        address,\\n        address,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal virtual override whenNotPaused returns (uint256, uint256[] memory) {\\n        // It would be strange for the Pool to be paused before it is initialized, but for consistency we prevent\\n        // initialization in this case.\\n\\n        WeightedPoolUserData.JoinKind kind = userData.joinKind();\\n        _require(kind == WeightedPoolUserData.JoinKind.INIT, Errors.UNINITIALIZED);\\n\\n        uint256[] memory amountsIn = userData.initialAmountsIn();\\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), amountsIn.length);\\n        _upscaleArray(amountsIn, scalingFactors);\\n\\n        (uint256[] memory normalizedWeights, ) = _getNormalizedWeightsAndMaxWeightIndex();\\n\\n        uint256 invariantAfterJoin = WeightedMath._calculateInvariant(normalizedWeights, amountsIn);\\n\\n        // Set the initial BPT to the value of the invariant times the number of tokens. This makes BPT supply more\\n        // consistent in Pools with similar compositions but different number of tokens.\\n        uint256 bptAmountOut = Math.mul(invariantAfterJoin, _getTotalTokens());\\n\\n        _lastInvariant = invariantAfterJoin;\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    // Join\\n\\n    function _onJoinPool(\\n        bytes32,\\n        address,\\n        address,\\n        uint256[] memory balances,\\n        uint256,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        override\\n        whenNotPaused\\n        returns (\\n            uint256,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        // All joins are disabled while the contract is paused.\\n\\n        (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex) = _getNormalizedWeightsAndMaxWeightIndex();\\n\\n        // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous join\\n        // or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids spending gas\\n        // computing them on each individual swap\\n        uint256 invariantBeforeJoin = WeightedMath._calculateInvariant(normalizedWeights, balances);\\n\\n        uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(\\n            balances,\\n            normalizedWeights,\\n            maxWeightTokenIndex,\\n            _lastInvariant,\\n            invariantBeforeJoin,\\n            protocolSwapFeePercentage\\n        );\\n\\n        // Update current balances by subtracting the protocol fee amounts\\n        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\\n        (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(\\n            balances,\\n            normalizedWeights,\\n            scalingFactors,\\n            userData\\n        );\\n\\n        // Update the invariant with the balances the Pool will have after the join, in order to compute the\\n        // protocol swap fee amounts due in future joins and exits.\\n        _lastInvariant = _invariantAfterJoin(balances, amountsIn, normalizedWeights);\\n\\n        return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);\\n    }\\n\\n    function _doJoin(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal returns (uint256, uint256[] memory) {\\n        WeightedPoolUserData.JoinKind kind = userData.joinKind();\\n\\n        if (kind == WeightedPoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT) {\\n            return _joinExactTokensInForBPTOut(balances, normalizedWeights, scalingFactors, userData);\\n        } else if (kind == WeightedPoolUserData.JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\\n            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\\n        } else if (kind == WeightedPoolUserData.JoinKind.ALL_TOKENS_IN_FOR_EXACT_BPT_OUT) {\\n            return _joinAllTokensInForExactBPTOut(balances, userData);\\n        } else {\\n            _revert(Errors.UNHANDLED_JOIN_KIND);\\n        }\\n    }\\n\\n    function _joinExactTokensInForBPTOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) private returns (uint256, uint256[] memory) {\\n        (uint256[] memory amountsIn, uint256 minBPTAmountOut) = userData.exactTokensInForBptOut();\\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), amountsIn.length);\\n\\n        _upscaleArray(amountsIn, scalingFactors);\\n\\n        (uint256 bptAmountOut, uint256[] memory swapFees) = WeightedMath._calcBptOutGivenExactTokensIn(\\n            balances,\\n            normalizedWeights,\\n            amountsIn,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n\\n        // Note that swapFees is already upscaled\\n        _processSwapFeeAmounts(swapFees);\\n\\n        _require(bptAmountOut >= minBPTAmountOut, Errors.BPT_OUT_MIN_AMOUNT);\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    function _joinTokenInForExactBPTOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        bytes memory userData\\n    ) private returns (uint256, uint256[] memory) {\\n        (uint256 bptAmountOut, uint256 tokenIndex) = userData.tokenInForExactBptOut();\\n        // Note that there is no maximum amountIn parameter: this is handled by `IVault.joinPool`.\\n\\n        _require(tokenIndex < _getTotalTokens(), Errors.OUT_OF_BOUNDS);\\n\\n        (uint256 amountIn, uint256 swapFee) = WeightedMath._calcTokenInGivenExactBptOut(\\n            balances[tokenIndex],\\n            normalizedWeights[tokenIndex],\\n            bptAmountOut,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n\\n        // Note that swapFee is already upscaled\\n        _processSwapFeeAmount(tokenIndex, swapFee);\\n\\n        // We join in a single token, so we initialize amountsIn with zeros\\n        uint256[] memory amountsIn = new uint256[](_getTotalTokens());\\n        // And then assign the result to the selected token\\n        amountsIn[tokenIndex] = amountIn;\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    function _joinAllTokensInForExactBPTOut(uint256[] memory balances, bytes memory userData)\\n        private\\n        view\\n        returns (uint256, uint256[] memory)\\n    {\\n        uint256 bptAmountOut = userData.allTokensInForExactBptOut();\\n        // Note that there is no maximum amountsIn parameter: this is handled by `IVault.joinPool`.\\n\\n        uint256[] memory amountsIn = WeightedMath._calcAllTokensInGivenExactBptOut(\\n            balances,\\n            bptAmountOut,\\n            totalSupply()\\n        );\\n\\n        return (bptAmountOut, amountsIn);\\n    }\\n\\n    // Exit\\n\\n    function _onExitPool(\\n        bytes32,\\n        address,\\n        address,\\n        uint256[] memory balances,\\n        uint256,\\n        uint256 protocolSwapFeePercentage,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        override\\n        returns (\\n            uint256 bptAmountIn,\\n            uint256[] memory amountsOut,\\n            uint256[] memory dueProtocolFeeAmounts\\n        )\\n    {\\n        (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex) = _getNormalizedWeightsAndMaxWeightIndex();\\n\\n        // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens\\n        // out) remain functional.\\n\\n        if (_isNotPaused()) {\\n            // Due protocol swap fee amounts are computed by measuring the growth of the invariant between the previous\\n            // join or exit event and now - the invariant's growth is due exclusively to swap fees. This avoids\\n            // spending gas calculating the fees on each individual swap.\\n            uint256 invariantBeforeExit = WeightedMath._calculateInvariant(normalizedWeights, balances);\\n            dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(\\n                balances,\\n                normalizedWeights,\\n                maxWeightTokenIndex,\\n                _lastInvariant,\\n                invariantBeforeExit,\\n                protocolSwapFeePercentage\\n            );\\n\\n            // Update current balances by subtracting the protocol fee amounts\\n            _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\\n        } else {\\n            // If the contract is paused, swap protocol fee amounts are not charged to avoid extra calculations and\\n            // reduce the potential for errors.\\n            dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\\n        }\\n\\n        (bptAmountIn, amountsOut) = _doExit(balances, normalizedWeights, scalingFactors, userData);\\n\\n        // Update the invariant with the balances the Pool will have after the exit, in order to compute the\\n        // protocol swap fees due in future joins and exits.\\n        _lastInvariant = _invariantAfterExit(balances, amountsOut, normalizedWeights);\\n\\n        return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);\\n    }\\n\\n    function _doExit(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal returns (uint256, uint256[] memory) {\\n        WeightedPoolUserData.ExitKind kind = userData.exitKind();\\n\\n        if (kind == WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT) {\\n            return _exitExactBPTInForTokenOut(balances, normalizedWeights, userData);\\n        } else if (kind == WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT) {\\n            return _exitExactBPTInForTokensOut(balances, userData);\\n        } else if (kind == WeightedPoolUserData.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT) {\\n            return _exitBPTInForExactTokensOut(balances, normalizedWeights, scalingFactors, userData);\\n        } else {\\n            _revert(Errors.UNHANDLED_EXIT_KIND);\\n        }\\n    }\\n\\n    function _exitExactBPTInForTokenOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        bytes memory userData\\n    ) private whenNotPaused returns (uint256, uint256[] memory) {\\n        // This exit function is disabled if the contract is paused.\\n\\n        (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();\\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\\n\\n        _require(tokenIndex < _getTotalTokens(), Errors.OUT_OF_BOUNDS);\\n\\n        (uint256 amountOut, uint256 swapFee) = WeightedMath._calcTokenOutGivenExactBptIn(\\n            balances[tokenIndex],\\n            normalizedWeights[tokenIndex],\\n            bptAmountIn,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n\\n        // This is an exceptional situation in which the fee is charged on a token out instead of a token in.\\n        // Note that swapFee is already upscaled.\\n        _processSwapFeeAmount(tokenIndex, swapFee);\\n\\n        // We exit in a single token, so we initialize amountsOut with zeros\\n        uint256[] memory amountsOut = new uint256[](_getTotalTokens());\\n        // And then assign the result to the selected token\\n        amountsOut[tokenIndex] = amountOut;\\n\\n        return (bptAmountIn, amountsOut);\\n    }\\n\\n    function _exitExactBPTInForTokensOut(uint256[] memory balances, bytes memory userData)\\n        private\\n        view\\n        returns (uint256, uint256[] memory)\\n    {\\n        // This exit function is the only one that is not disabled if the contract is paused: it remains unrestricted\\n        // in an attempt to provide users with a mechanism to retrieve their tokens in case of an emergency.\\n        // This particular exit function is the only one that remains available because it is the simplest one, and\\n        // therefore the one with the lowest likelihood of errors.\\n\\n        uint256 bptAmountIn = userData.exactBptInForTokensOut();\\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\\n\\n        uint256[] memory amountsOut = WeightedMath._calcTokensOutGivenExactBptIn(balances, bptAmountIn, totalSupply());\\n        return (bptAmountIn, amountsOut);\\n    }\\n\\n    function _exitBPTInForExactTokensOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) private whenNotPaused returns (uint256, uint256[] memory) {\\n        // This exit function is disabled if the contract is paused.\\n\\n        (uint256[] memory amountsOut, uint256 maxBPTAmountIn) = userData.bptInForExactTokensOut();\\n        InputHelpers.ensureInputLengthMatch(amountsOut.length, _getTotalTokens());\\n        _upscaleArray(amountsOut, scalingFactors);\\n\\n        (uint256 bptAmountIn, uint256[] memory swapFees) = WeightedMath._calcBptInGivenExactTokensOut(\\n            balances,\\n            normalizedWeights,\\n            amountsOut,\\n            totalSupply(),\\n            getSwapFeePercentage()\\n        );\\n        _require(bptAmountIn <= maxBPTAmountIn, Errors.BPT_IN_MAX_AMOUNT);\\n\\n        // This is an exceptional situation in which the fee is charged on a token out instead of a token in.\\n        // Note that swapFee is already upscaled.\\n        _processSwapFeeAmounts(swapFees);\\n\\n        return (bptAmountIn, amountsOut);\\n    }\\n\\n    // Helpers\\n\\n    function _getDueProtocolFeeAmounts(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256 maxWeightTokenIndex,\\n        uint256 previousInvariant,\\n        uint256 currentInvariant,\\n        uint256 protocolSwapFeePercentage\\n    ) private view returns (uint256[] memory) {\\n        // Initialize with zeros\\n        uint256[] memory dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\\n\\n        // Early return if the protocol swap fee percentage is zero, saving gas.\\n        if (protocolSwapFeePercentage == 0) {\\n            return dueProtocolFeeAmounts;\\n        }\\n\\n        // The protocol swap fees are always paid using the token with the largest weight in the Pool. As this is the\\n        // token that is expected to have the largest balance, using it to pay fees should not unbalance the Pool.\\n        dueProtocolFeeAmounts[maxWeightTokenIndex] = WeightedMath._calcDueTokenProtocolSwapFeeAmount(\\n            balances[maxWeightTokenIndex],\\n            normalizedWeights[maxWeightTokenIndex],\\n            previousInvariant,\\n            currentInvariant,\\n            protocolSwapFeePercentage\\n        );\\n\\n        return dueProtocolFeeAmounts;\\n    }\\n\\n    /**\\n     * @dev Returns the value of the invariant given `balances`, assuming they are increased by `amountsIn`. All\\n     * amounts are expected to be upscaled.\\n     */\\n    function _invariantAfterJoin(\\n        uint256[] memory balances,\\n        uint256[] memory amountsIn,\\n        uint256[] memory normalizedWeights\\n    ) private view returns (uint256) {\\n        _mutateAmounts(balances, amountsIn, FixedPoint.add);\\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\\n    }\\n\\n    function _invariantAfterExit(\\n        uint256[] memory balances,\\n        uint256[] memory amountsOut,\\n        uint256[] memory normalizedWeights\\n    ) private view returns (uint256) {\\n        _mutateAmounts(balances, amountsOut, FixedPoint.sub);\\n        return WeightedMath._calculateInvariant(normalizedWeights, balances);\\n    }\\n\\n    /**\\n     * @dev Mutates `amounts` by applying `mutation` with each entry in `arguments`.\\n     *\\n     * Equivalent to `amounts = amounts.map(mutation)`.\\n     */\\n    function _mutateAmounts(\\n        uint256[] memory toMutate,\\n        uint256[] memory arguments,\\n        function(uint256, uint256) pure returns (uint256) mutation\\n    ) private view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            toMutate[i] = mutation(toMutate[i], arguments[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev This function returns the appreciation of one BPT relative to the\\n     * underlying tokens. This starts at 1 when the pool is created and grows over time\\n     */\\n    function getRate() public view returns (uint256) {\\n        // The initial BPT supply is equal to the invariant times the number of tokens.\\n        return Math.mul(getInvariant(), _getTotalTokens()).divDown(totalSupply());\\n    }\\n}\\n\",\"keccak256\":\"0x123fec7508547c0d8a42552807acd2f1f485cf646e53cab58feef0aa70ce8ed0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-weighted/contracts/WeightedMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../solidity-utils/contracts/math/FixedPoint.sol\\\";\\nimport \\\"../../solidity-utils/contracts/math/Math.sol\\\";\\nimport \\\"../../solidity-utils/contracts/helpers/InputHelpers.sol\\\";\\n\\n// These functions start with an underscore, as if they were part of a contract and not a library. At some point this\\n// should be fixed.\\n// solhint-disable private-vars-leading-underscore\\n\\nlibrary WeightedMath {\\n    using FixedPoint for uint256;\\n    // A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\\n    // implementation of the power function, as these ratios are often exponents.\\n    uint256 internal constant _MIN_WEIGHT = 0.01e18;\\n    // Having a minimum normalized weight imposes a limit on the maximum number of tokens;\\n    // i.e., the largest possible pool is one where all tokens have exactly the minimum weight.\\n    uint256 internal constant _MAX_WEIGHTED_TOKENS = 100;\\n\\n    // Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\\n    // ratio).\\n\\n    // Swap limits: amounts swapped may not be larger than this percentage of total balance.\\n    uint256 internal constant _MAX_IN_RATIO = 0.3e18;\\n    uint256 internal constant _MAX_OUT_RATIO = 0.3e18;\\n\\n    // Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\\n    uint256 internal constant _MAX_INVARIANT_RATIO = 3e18;\\n    // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\\n    uint256 internal constant _MIN_INVARIANT_RATIO = 0.7e18;\\n\\n    // About swap fees on joins and exits:\\n    // Any join or exit that is not perfectly balanced (e.g. all single token joins or exits) is mathematically\\n    // equivalent to a perfectly balanced join or  exit followed by a series of swaps. Since these swaps would charge\\n    // swap fees, it follows that (some) joins and exits should as well.\\n    // On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\\n    // is the one to which swap fees are applied.\\n\\n    // Invariant is used to collect protocol swap fees by comparing its value between two times.\\n    // So we can round always to the same direction. It is also used to initiate the BPT amount\\n    // and, because there is a minimum BPT, we round down the invariant.\\n    function _calculateInvariant(uint256[] memory normalizedWeights, uint256[] memory balances)\\n        internal\\n        pure\\n        returns (uint256 invariant)\\n    {\\n        /**********************************************************************************************\\n        // invariant               _____                                                             //\\n        // wi = weight index i      | |      wi                                                      //\\n        // bi = balance index i     | |  bi ^   = i                                                  //\\n        // i = invariant                                                                             //\\n        **********************************************************************************************/\\n\\n        invariant = FixedPoint.ONE;\\n        for (uint256 i = 0; i < normalizedWeights.length; i++) {\\n            invariant = invariant.mulDown(balances[i].powDown(normalizedWeights[i]));\\n        }\\n\\n        _require(invariant > 0, Errors.ZERO_INVARIANT);\\n    }\\n\\n    // Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\\n    // current balances and weights.\\n    function _calcOutGivenIn(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountIn\\n    ) internal pure returns (uint256) {\\n        /**********************************************************************************************\\n        // outGivenIn                                                                                //\\n        // aO = amountOut                                                                            //\\n        // bO = balanceOut                                                                           //\\n        // bI = balanceIn              /      /            bI             \\\\    (wI / wO) \\\\           //\\n        // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\\n        // wI = weightIn               \\\\      \\\\       ( bI + aI )         /              /           //\\n        // wO = weightOut                                                                            //\\n        **********************************************************************************************/\\n\\n        // Amount out, so we round down overall.\\n\\n        // The multiplication rounds down, and the subtrahend (power) rounds up (so the base rounds up too).\\n        // Because bI / (bI + aI) <= 1, the exponent rounds down.\\n\\n        // Cannot exceed maximum in ratio\\n        _require(amountIn <= balanceIn.mulDown(_MAX_IN_RATIO), Errors.MAX_IN_RATIO);\\n\\n        uint256 denominator = balanceIn.add(amountIn);\\n        uint256 base = balanceIn.divUp(denominator);\\n        uint256 exponent = weightIn.divDown(weightOut);\\n        uint256 power = base.powUp(exponent);\\n\\n        return balanceOut.mulDown(power.complement());\\n    }\\n\\n    // Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\\n    // current balances and weights.\\n    function _calcInGivenOut(\\n        uint256 balanceIn,\\n        uint256 weightIn,\\n        uint256 balanceOut,\\n        uint256 weightOut,\\n        uint256 amountOut\\n    ) internal pure returns (uint256) {\\n        /**********************************************************************************************\\n        // inGivenOut                                                                                //\\n        // aO = amountOut                                                                            //\\n        // bO = balanceOut                                                                           //\\n        // bI = balanceIn              /  /            bO             \\\\    (wO / wI)      \\\\          //\\n        // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\\n        // wI = weightIn               \\\\  \\\\       ( bO - aO )         /                   /          //\\n        // wO = weightOut                                                                            //\\n        **********************************************************************************************/\\n\\n        // Amount in, so we round up overall.\\n\\n        // The multiplication rounds up, and the power rounds up (so the base rounds up too).\\n        // Because b0 / (b0 - a0) >= 1, the exponent rounds up.\\n\\n        // Cannot exceed maximum out ratio\\n        _require(amountOut <= balanceOut.mulDown(_MAX_OUT_RATIO), Errors.MAX_OUT_RATIO);\\n\\n        uint256 base = balanceOut.divUp(balanceOut.sub(amountOut));\\n        uint256 exponent = weightOut.divUp(weightIn);\\n        uint256 power = base.powUp(exponent);\\n\\n        // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\\n        // the following subtraction should never revert.\\n        uint256 ratio = power.sub(FixedPoint.ONE);\\n\\n        return balanceIn.mulUp(ratio);\\n    }\\n\\n    function _calcBptOutGivenExactTokensIn(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        // BPT out, so we round down overall.\\n\\n        uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\\n\\n        uint256 invariantRatioWithFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);\\n            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(normalizedWeights[i]));\\n        }\\n\\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeJoinExactTokensInInvariantRatio(\\n            balances,\\n            normalizedWeights,\\n            amountsIn,\\n            balanceRatiosWithFee,\\n            invariantRatioWithFees,\\n            swapFeePercentage\\n        );\\n\\n        uint256 bptOut = (invariantRatio > FixedPoint.ONE)\\n            ? bptTotalSupply.mulDown(invariantRatio.sub(FixedPoint.ONE))\\n            : 0;\\n        return (bptOut, swapFees);\\n    }\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep errors.\\n     */\\n    function _computeJoinExactTokensInInvariantRatio(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsIn,\\n        uint256[] memory balanceRatiosWithFee,\\n        uint256 invariantRatioWithFees,\\n        uint256 swapFeePercentage\\n    ) private pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\\n        // Swap fees are charged on all tokens that are being added in a larger proportion than the overall invariant\\n        // increase.\\n        swapFees = new uint256[](amountsIn.length);\\n        invariantRatio = FixedPoint.ONE;\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            uint256 amountInWithoutFee;\\n\\n            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));\\n                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);\\n                uint256 swapFee = taxableAmount.mulUp(swapFeePercentage);\\n\\n                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.sub(swapFee));\\n                swapFees[i] = swapFee;\\n            } else {\\n                amountInWithoutFee = amountsIn[i];\\n            }\\n\\n            uint256 balanceRatio = balances[i].add(amountInWithoutFee).divDown(balances[i]);\\n\\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\\n        }\\n    }\\n\\n    function _calcTokenInGivenExactBptOut(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256 amountIn, uint256 swapFee) {\\n        /******************************************************************************************\\n        // tokenInForExactBPTOut                                                                 //\\n        // a = amountIn                                                                          //\\n        // b = balance                      /  /    totalBPT + bptOut      \\\\    (1 / w)       \\\\  //\\n        // bptOut = bptAmountOut   a = b * |  | --------------------------  | ^          - 1  |  //\\n        // bpt = totalBPT                   \\\\  \\\\       totalBPT            /                  /  //\\n        // w = weight                                                                            //\\n        ******************************************************************************************/\\n\\n        // Token in, so we round up overall.\\n\\n        // Calculate the factor by which the invariant will increase after minting BPTAmountOut\\n        uint256 invariantRatio = bptTotalSupply.add(bptAmountOut).divUp(bptTotalSupply);\\n        _require(invariantRatio <= _MAX_INVARIANT_RATIO, Errors.MAX_OUT_BPT_FOR_TOKEN_IN);\\n\\n        // Calculate by how much the token balance has to increase to match the invariantRatio\\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divUp(normalizedWeight));\\n\\n        uint256 amountInWithoutFee = balance.mulUp(balanceRatio.sub(FixedPoint.ONE));\\n\\n        // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees\\n        // accordingly.\\n        uint256 taxablePercentage = normalizedWeight.complement();\\n        uint256 taxableAmount = amountInWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountInWithoutFee.sub(taxableAmount);\\n\\n        uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE.sub(swapFeePercentage));\\n\\n        swapFee = taxableAmountPlusFees - taxableAmount;\\n        amountIn = nonTaxableAmount.add(taxableAmountPlusFees);\\n    }\\n\\n    function _calcAllTokensInGivenExactBptOut(\\n        uint256[] memory balances,\\n        uint256 bptAmountOut,\\n        uint256 totalBPT\\n    ) internal pure returns (uint256[] memory) {\\n        /************************************************************************************\\n        // tokensInForExactBptOut                                                          //\\n        // (per token)                                                                     //\\n        // aI = amountIn                   /   bptOut   \\\\                                  //\\n        // b = balance           aI = b * | ------------ |                                 //\\n        // bptOut = bptAmountOut           \\\\  totalBPT  /                                  //\\n        // bpt = totalBPT                                                                  //\\n        ************************************************************************************/\\n\\n        // Tokens in, so we round up overall.\\n        uint256 bptRatio = bptAmountOut.divUp(totalBPT);\\n\\n        uint256[] memory amountsIn = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsIn[i] = balances[i].mulUp(bptRatio);\\n        }\\n\\n        return amountsIn;\\n    }\\n\\n    function _calcBptInGivenExactTokensOut(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        // BPT in, so we round up overall.\\n\\n        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);\\n        uint256 invariantRatioWithoutFees = 0;\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            balanceRatiosWithoutFee[i] = balances[i].sub(amountsOut[i]).divUp(balances[i]);\\n            invariantRatioWithoutFees = invariantRatioWithoutFees.add(\\n                balanceRatiosWithoutFee[i].mulUp(normalizedWeights[i])\\n            );\\n        }\\n\\n        (uint256 invariantRatio, uint256[] memory swapFees) = _computeExitExactTokensOutInvariantRatio(\\n            balances,\\n            normalizedWeights,\\n            amountsOut,\\n            balanceRatiosWithoutFee,\\n            invariantRatioWithoutFees,\\n            swapFeePercentage\\n        );\\n\\n        uint256 bptIn = bptTotalSupply.mulUp(invariantRatio.complement());\\n        return (bptIn, swapFees);\\n    }\\n\\n    /**\\n     * @dev Intermediate function to avoid stack-too-deep errors.\\n     */\\n    function _computeExitExactTokensOutInvariantRatio(\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory amountsOut,\\n        uint256[] memory balanceRatiosWithoutFee,\\n        uint256 invariantRatioWithoutFees,\\n        uint256 swapFeePercentage\\n    ) private pure returns (uint256 invariantRatio, uint256[] memory swapFees) {\\n        swapFees = new uint256[](amountsOut.length);\\n        invariantRatio = FixedPoint.ONE;\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\\n            // 'token out'. This results in slightly larger price impact.\\n\\n            uint256 amountOutWithFee;\\n            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\\n                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());\\n                uint256 taxableAmount = amountsOut[i].sub(nonTaxableAmount);\\n                uint256 taxableAmountPlusFees = taxableAmount.divUp(FixedPoint.ONE.sub(swapFeePercentage));\\n\\n                swapFees[i] = taxableAmountPlusFees - taxableAmount;\\n                amountOutWithFee = nonTaxableAmount.add(taxableAmountPlusFees);\\n            } else {\\n                amountOutWithFee = amountsOut[i];\\n            }\\n\\n            uint256 balanceRatio = balances[i].sub(amountOutWithFee).divDown(balances[i]);\\n\\n            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));\\n        }\\n    }\\n\\n    function _calcTokenOutGivenExactBptIn(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 bptAmountIn,\\n        uint256 bptTotalSupply,\\n        uint256 swapFeePercentage\\n    ) internal pure returns (uint256 amountOut, uint256 swapFee) {\\n        /*****************************************************************************************\\n        // exactBPTInForTokenOut                                                                //\\n        // a = amountOut                                                                        //\\n        // b = balance                     /      /    totalBPT - bptIn       \\\\    (1 / w)  \\\\   //\\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\\n        // bpt = totalBPT                  \\\\      \\\\       totalBPT            /             /   //\\n        // w = weight                                                                           //\\n        *****************************************************************************************/\\n\\n        // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\\n        // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\\n\\n        // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\\n        uint256 invariantRatio = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply);\\n        _require(invariantRatio >= _MIN_INVARIANT_RATIO, Errors.MIN_BPT_IN_FOR_TOKEN_OUT);\\n\\n        // Calculate by how much the token balance has to decrease to match invariantRatio\\n        uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divDown(normalizedWeight));\\n\\n        // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\\n        uint256 amountOutWithoutFee = balance.mulDown(balanceRatio.complement());\\n\\n        // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\\n        // in swap fees.\\n        uint256 taxablePercentage = normalizedWeight.complement();\\n\\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\\n        // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\\n        uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\\n        uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\\n\\n        swapFee = taxableAmount.mulUp(swapFeePercentage);\\n        amountOut = nonTaxableAmount.add(taxableAmount.sub(swapFee));\\n    }\\n\\n    function _calcTokensOutGivenExactBptIn(\\n        uint256[] memory balances,\\n        uint256 bptAmountIn,\\n        uint256 totalBPT\\n    ) internal pure returns (uint256[] memory) {\\n        /**********************************************************************************************\\n        // exactBPTInForTokensOut                                                                    //\\n        // (per token)                                                                               //\\n        // aO = amountOut                  /        bptIn         \\\\                                  //\\n        // b = balance           a0 = b * | ---------------------  |                                 //\\n        // bptIn = bptAmountIn             \\\\       totalBPT       /                                  //\\n        // bpt = totalBPT                                                                            //\\n        **********************************************************************************************/\\n\\n        // Since we're computing an amount out, we round down overall. This means rounding down on both the\\n        // multiplication and division.\\n\\n        uint256 bptRatio = bptAmountIn.divDown(totalBPT);\\n\\n        uint256[] memory amountsOut = new uint256[](balances.length);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amountsOut[i] = balances[i].mulDown(bptRatio);\\n        }\\n\\n        return amountsOut;\\n    }\\n\\n    function _calcDueTokenProtocolSwapFeeAmount(\\n        uint256 balance,\\n        uint256 normalizedWeight,\\n        uint256 previousInvariant,\\n        uint256 currentInvariant,\\n        uint256 protocolSwapFeePercentage\\n    ) internal pure returns (uint256) {\\n        /*********************************************************************************\\n        /*  protocolSwapFeePercentage * balanceToken * ( 1 - (previousInvariant / currentInvariant) ^ (1 / weightToken))\\n        *********************************************************************************/\\n\\n        if (currentInvariant <= previousInvariant) {\\n            // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\\n            // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\\n            return 0;\\n        }\\n\\n        // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\\n        // fees to the Vault.\\n\\n        // Fee percentage and balance multiplications round down, while the subtrahend (power) rounds up (as does the\\n        // base). Because previousInvariant / currentInvariant <= 1, the exponent rounds down.\\n\\n        uint256 base = previousInvariant.divUp(currentInvariant);\\n        uint256 exponent = FixedPoint.ONE.divDown(normalizedWeight);\\n\\n        // Because the exponent is larger than one, the base of the power function has a lower bound. We cap to this\\n        // value to avoid numeric issues, which means in the extreme case (where the invariant growth is larger than\\n        // 1 / min exponent) the Pool will pay less in protocol fees than it should.\\n        base = Math.max(base, FixedPoint.MIN_POW_BASE_FREE_EXPONENT);\\n\\n        uint256 power = base.powUp(exponent);\\n\\n        uint256 tokenAccruedFees = balance.mulDown(power.complement());\\n        return tokenAccruedFees.mulDown(protocolSwapFeePercentage);\\n    }\\n}\\n\",\"keccak256\":\"0x30c43610fecb4b460d0608a77db7be793ad30e593aeea7b5c0d0cbd818d95c74\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-weighted/contracts/WeightedPoolUserData.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\nlibrary WeightedPoolUserData {\\n    // In order to preserve backwards compatibility, make sure new join and exit kinds are added at the end of the enum.\\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT, ALL_TOKENS_IN_FOR_EXACT_BPT_OUT }\\n    enum ExitKind {\\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\\n        EXACT_BPT_IN_FOR_TOKENS_OUT,\\n        BPT_IN_FOR_EXACT_TOKENS_OUT,\\n        MANAGEMENT_FEE_TOKENS_OUT // for ManagedPool\\n    }\\n\\n    function joinKind(bytes memory self) internal pure returns (JoinKind) {\\n        return abi.decode(self, (JoinKind));\\n    }\\n\\n    function exitKind(bytes memory self) internal pure returns (ExitKind) {\\n        return abi.decode(self, (ExitKind));\\n    }\\n\\n    // Joins\\n\\n    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {\\n        (, amountsIn) = abi.decode(self, (JoinKind, uint256[]));\\n    }\\n\\n    function exactTokensInForBptOut(bytes memory self)\\n        internal\\n        pure\\n        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)\\n    {\\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (JoinKind, uint256[], uint256));\\n    }\\n\\n    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {\\n        (, bptAmountOut, tokenIndex) = abi.decode(self, (JoinKind, uint256, uint256));\\n    }\\n\\n    function allTokensInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut) {\\n        (, bptAmountOut) = abi.decode(self, (JoinKind, uint256));\\n    }\\n\\n    // Exits\\n\\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (ExitKind, uint256, uint256));\\n    }\\n\\n    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {\\n        (, bptAmountIn) = abi.decode(self, (ExitKind, uint256));\\n    }\\n\\n    function bptInForExactTokensOut(bytes memory self)\\n        internal\\n        pure\\n        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)\\n    {\\n        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (ExitKind, uint256[], uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x9ef2267f4bea8464a3c485e18a497fdd7063e35e3fac08b70bfc36fabec5a0e9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-weighted/contracts/smart/ManagedPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../solidity-utils/contracts/openzeppelin/EnumerableMap.sol\\\";\\nimport \\\"../../../solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol\\\";\\nimport \\\"../../../solidity-utils/contracts/helpers/ERC20Helpers.sol\\\";\\nimport \\\"../../../solidity-utils/contracts/helpers/WordCodec.sol\\\";\\n\\nimport \\\"../BaseWeightedPool.sol\\\";\\nimport \\\"../WeightedPoolUserData.sol\\\";\\nimport \\\"./WeightCompression.sol\\\";\\n\\n/**\\n * @dev Weighted Pool with mutable tokens and weights, designed to be used in conjunction with a pool controller\\n * contract (as the owner, containing any specific business logic). Since the pool itself permits \\\"dangerous\\\"\\n * operations, it should never be deployed with an EOA as the owner.\\n *\\n * Pool controllers can add functionality: for example, allow the effective \\\"owner\\\" to be transferred to another\\n * address. (The actual pool owner is still immutable, set to the pool controller contract.) Another pool owner\\n * might allow fine-grained permissioning of protected operations: perhaps a multisig can add/remove tokens, but\\n * a third-party EOA is allowed to set the swap fees.\\n *\\n * Pool controllers might also impose limits on functionality so that operations that might endanger LPs can be\\n * performed more safely. For instance, the pool by itself places no restrictions on the duration of a gradual\\n * weight change, but a pool controller might restrict this in various ways, from a simple minimum duration,\\n * to a more complex rate limit.\\n *\\n * Pool controllers can also serve as intermediate contracts to hold tokens, deploy timelocks, consult with other\\n * protocols or on-chain oracles, or bundle several operations into one transaction that re-entrancy protection\\n * would prevent initiating from the pool contract.\\n *\\n * Managed Pools and their controllers are designed to support many asset management use cases, including: large\\n * token counts, rebalancing through token changes, gradual weight or fee updates, circuit breakers for\\n * IL-protection, and more.\\n */\\ncontract ManagedPool is BaseWeightedPool, ReentrancyGuard {\\n    // solhint-disable not-rely-on-time\\n\\n    using FixedPoint for uint256;\\n    using WordCodec for bytes32;\\n    using WeightCompression for uint256;\\n    using WeightedPoolUserData for bytes;\\n    using EnumerableMap for EnumerableMap.IERC20ToUint256Map;\\n\\n    // State variables\\n\\n    // The upper bound is WeightedMath.MAX_WEIGHTED_TOKENS, but this is constrained by other factors, such as Pool\\n    // creation gas consumption.\\n    uint256 private constant _MAX_MANAGED_TOKENS = 50;\\n\\n    // Percentage of swap fees that are allocated to the Pool owner.\\n    uint256 private immutable _managementSwapFeePercentage;\\n    uint256 private constant _MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 1e18; // 100%\\n\\n    // Use the _miscData slot in BasePool\\n    // First 64 bits are reserved for the swap fee\\n    //\\n    // Store non-token-based values:\\n    // Start/end timestamps for gradual weight update\\n    // Cache total tokens\\n    // [ 64 bits  | 119 bits |    1 bit    |  32 bits  |   32 bits  |    7 bits    |   1 bit   ]\\n    // [ reserved |  unused  | restrict LP | end time  | start time | total tokens | swap flag ]\\n    // |MSB                                                                                 LSB|\\n    uint256 private constant _SWAP_ENABLED_OFFSET = 0;\\n    uint256 private constant _TOTAL_TOKENS_OFFSET = 1;\\n    uint256 private constant _START_TIME_OFFSET = 8;\\n    uint256 private constant _END_TIME_OFFSET = 40;\\n    uint256 private constant _MUST_ALLOWLIST_LPS_OFFSET = 72;\\n\\n    // 7 bits is enough for the token count, since _MAX_MANAGED_TOKENS is 50\\n\\n    // Store scaling factor and start/end weights for each token\\n    // Mapping should be more efficient than trying to compress it further\\n    // [ 155 bits|   5 bits |  32 bits   |   64 bits    |\\n    // [ unused  | decimals | end weight | start weight |\\n    // |MSB                                          LSB|\\n    mapping(IERC20 => bytes32) private _tokenState;\\n\\n    EnumerableMap.IERC20ToUint256Map private _tokenCollectedManagementFees;\\n\\n    uint256 private constant _START_WEIGHT_OFFSET = 0;\\n    uint256 private constant _END_WEIGHT_OFFSET = 64;\\n    uint256 private constant _DECIMAL_DIFF_OFFSET = 96;\\n\\n    // If mustAllowlistLPs is enabled, this is the list of addresses allowed to join the pool\\n    mapping(address => bool) private _allowedAddresses;\\n\\n    // Event declarations\\n\\n    event GradualWeightUpdateScheduled(\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256[] startWeights,\\n        uint256[] endWeights\\n    );\\n    event SwapEnabledSet(bool swapEnabled);\\n    event MustAllowlistLPsSet(bool mustAllowlistLPs);\\n    event ManagementFeePercentageChanged(uint256 managementFeePercentage);\\n    event ManagementFeesCollected(IERC20[] tokens, uint256[] amounts);\\n    event AllowlistAddressAdded(address indexed member);\\n    event AllowlistAddressRemoved(address indexed member);\\n\\n    struct NewPoolParams {\\n        IVault vault;\\n        string name;\\n        string symbol;\\n        IERC20[] tokens;\\n        uint256[] normalizedWeights;\\n        address[] assetManagers;\\n        uint256 swapFeePercentage;\\n        uint256 pauseWindowDuration;\\n        uint256 bufferPeriodDuration;\\n        address owner;\\n        bool swapEnabledOnStart;\\n        bool mustAllowlistLPs;\\n        uint256 managementSwapFeePercentage;\\n    }\\n\\n    constructor(NewPoolParams memory params)\\n        BaseWeightedPool(\\n            params.vault,\\n            params.name,\\n            params.symbol,\\n            params.tokens,\\n            params.assetManagers,\\n            params.swapFeePercentage,\\n            params.pauseWindowDuration,\\n            params.bufferPeriodDuration,\\n            params.owner\\n        )\\n    {\\n        uint256 totalTokens = params.tokens.length;\\n        InputHelpers.ensureInputLengthMatch(totalTokens, params.normalizedWeights.length, params.assetManagers.length);\\n\\n        _setMiscData(_getMiscData().insertUint7(totalTokens, _TOTAL_TOKENS_OFFSET));\\n\\n        // Double check it fits in 7 bits\\n        _require(_getTotalTokens() == totalTokens, Errors.MAX_TOKENS);\\n\\n        // This must be inlined in the constructor as we're setting an immutable variable.\\n        _require(\\n            params.managementSwapFeePercentage <= _MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE,\\n            Errors.MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE\\n        );\\n\\n        uint256 currentTime = block.timestamp;\\n        _startGradualWeightChange(\\n            currentTime,\\n            currentTime,\\n            params.normalizedWeights,\\n            params.normalizedWeights,\\n            params.tokens\\n        );\\n\\n        // Initialize the accrued management fees map with the Pool's tokens and zero collected fees.\\n        for (uint256 i = 0; i < totalTokens; ++i) {\\n            _tokenCollectedManagementFees.set(params.tokens[i], 0);\\n        }\\n\\n        // If false, the pool will start in the disabled state (prevents front-running the enable swaps transaction).\\n        _setSwapEnabled(params.swapEnabledOnStart);\\n\\n        // If true, only addresses on the manager-controlled allowlist may join the pool.\\n        _setMustAllowlistLPs(params.mustAllowlistLPs);\\n\\n        _managementSwapFeePercentage = params.managementSwapFeePercentage;\\n\\n        emit ManagementFeePercentageChanged(params.managementSwapFeePercentage);\\n    }\\n\\n    /**\\n     * @dev Returns true if swaps are enabled.\\n     */\\n    function getSwapEnabled() public view returns (bool) {\\n        return _getMiscData().decodeBool(_SWAP_ENABLED_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Returns true if the allowlist for LPs is enabled.\\n     */\\n    function getMustAllowlistLPs() public view returns (bool) {\\n        return _getMiscData().decodeBool(_MUST_ALLOWLIST_LPS_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Verifies that a given address is allowed to hold tokens.\\n     */\\n    function isAllowedAddress(address member) public view returns (bool) {\\n        return !getMustAllowlistLPs() || _allowedAddresses[member];\\n    }\\n\\n    /**\\n     * @dev Returns the management swap fee percentage as a 18-decimals fixed point number.\\n     */\\n    function getManagementSwapFeePercentage() public view returns (uint256) {\\n        return _managementSwapFeePercentage;\\n    }\\n\\n    /**\\n     * @dev Return start time, end time, and endWeights as an array.\\n     * Current weights should be retrieved via `getNormalizedWeights()`.\\n     */\\n    function getGradualWeightUpdateParams()\\n        external\\n        view\\n        returns (\\n            uint256 startTime,\\n            uint256 endTime,\\n            uint256[] memory endWeights\\n        )\\n    {\\n        // Load current pool state from storage\\n        bytes32 poolState = _getMiscData();\\n\\n        startTime = poolState.decodeUint32(_START_TIME_OFFSET);\\n        endTime = poolState.decodeUint32(_END_TIME_OFFSET);\\n\\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\\n        uint256 totalTokens = tokens.length;\\n\\n        endWeights = new uint256[](totalTokens);\\n\\n        for (uint256 i = 0; i < totalTokens; i++) {\\n            endWeights[i] = _tokenState[tokens[i]].decodeUint32(_END_WEIGHT_OFFSET).uncompress32();\\n        }\\n    }\\n\\n    function _getMaxTokens() internal pure virtual override returns (uint256) {\\n        return _MAX_MANAGED_TOKENS;\\n    }\\n\\n    function _getTotalTokens() internal view virtual override returns (uint256) {\\n        return _getMiscData().decodeUint7(_TOTAL_TOKENS_OFFSET);\\n    }\\n\\n    /**\\n     * @dev Schedule a gradual weight change, from the current weights to the given endWeights,\\n     * over startTime to endTime.\\n     */\\n    function updateWeightsGradually(\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256[] memory endWeights\\n    ) external authenticate whenNotPaused nonReentrant {\\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), endWeights.length);\\n\\n        // If the start time is in the past, \\\"fast forward\\\" to start now\\n        // This avoids discontinuities in the weight curve. Otherwise, if you set the start/end times with\\n        // only 10% of the period in the future, the weights would immediately jump 90%\\n        uint256 currentTime = block.timestamp;\\n        startTime = Math.max(currentTime, startTime);\\n\\n        _require(startTime <= endTime, Errors.GRADUAL_UPDATE_TIME_TRAVEL);\\n\\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\\n\\n        _startGradualWeightChange(startTime, endTime, _getNormalizedWeights(), endWeights, tokens);\\n    }\\n\\n    function getCollectedManagementFees() public view returns (IERC20[] memory tokens, uint256[] memory collectedFees) {\\n        tokens = new IERC20[](_getTotalTokens());\\n        collectedFees = new uint256[](_getTotalTokens());\\n\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            // We can use unchecked getters as we know the map has the same size (and order!) as the Pool's tokens.\\n            (IERC20 token, uint256 fees) = _tokenCollectedManagementFees.unchecked_at(i);\\n            tokens[i] = token;\\n            collectedFees[i] = fees;\\n        }\\n\\n        _downscaleDownArray(collectedFees, _scalingFactors());\\n    }\\n\\n    function withdrawCollectedManagementFees(address recipient) external authenticate whenNotPaused nonReentrant {\\n        (IERC20[] memory tokens, uint256[] memory collectedFees) = getCollectedManagementFees();\\n\\n        getVault().exitPool(\\n            getPoolId(),\\n            address(this),\\n            payable(recipient),\\n            IVault.ExitPoolRequest({\\n                assets: _asIAsset(tokens),\\n                minAmountsOut: collectedFees,\\n                userData: abi.encode(WeightedPoolUserData.ExitKind.MANAGEMENT_FEE_TOKENS_OUT),\\n                toInternalBalance: false\\n            })\\n        );\\n\\n        // Technically collectedFees is the minimum amount, not the actual amount. However, since no fees will be\\n        // collected during the exit, it will also be the actual amount.\\n        emit ManagementFeesCollected(tokens, collectedFees);\\n    }\\n\\n    /**\\n     * @dev Adds an address to the allowlist.\\n     */\\n    function addAllowedAddress(address member) external authenticate whenNotPaused {\\n        _require(getMustAllowlistLPs(), Errors.UNAUTHORIZED_OPERATION);\\n        _require(!_allowedAddresses[member], Errors.ADDRESS_ALREADY_ALLOWLISTED);\\n\\n        _allowedAddresses[member] = true;\\n        emit AllowlistAddressAdded(member);\\n    }\\n\\n    /**\\n     * @dev Removes an address from the allowlist.\\n     */\\n    function removeAllowedAddress(address member) external authenticate whenNotPaused {\\n        _require(_allowedAddresses[member], Errors.ADDRESS_NOT_ALLOWLISTED);\\n\\n        delete _allowedAddresses[member];\\n        emit AllowlistAddressRemoved(member);\\n    }\\n\\n    /**\\n     * @dev Can enable/disable the LP allowlist. Note that any addresses added to the allowlist\\n     * will be retained if the allowlist is toggled off and back on again.\\n     */\\n    function setMustAllowlistLPs(bool mustAllowlistLPs) external authenticate whenNotPaused {\\n        _setMustAllowlistLPs(mustAllowlistLPs);\\n    }\\n\\n    function _setMustAllowlistLPs(bool mustAllowlistLPs) private {\\n        _setMiscData(_getMiscData().insertBool(mustAllowlistLPs, _MUST_ALLOWLIST_LPS_OFFSET));\\n\\n        emit MustAllowlistLPsSet(mustAllowlistLPs);\\n    }\\n\\n    /**\\n     * @dev Can enable/disable trading\\n     */\\n    function setSwapEnabled(bool swapEnabled) external authenticate whenNotPaused {\\n        _setSwapEnabled(swapEnabled);\\n    }\\n\\n    function _setSwapEnabled(bool swapEnabled) private {\\n        _setMiscData(_getMiscData().insertBool(swapEnabled, _SWAP_ENABLED_OFFSET));\\n\\n        emit SwapEnabledSet(swapEnabled);\\n    }\\n\\n    function _scalingFactor(IERC20 token) internal view virtual override returns (uint256) {\\n        return _readScalingFactor(_getTokenData(token));\\n    }\\n\\n    function _scalingFactors() internal view virtual override returns (uint256[] memory scalingFactors) {\\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\\n        uint256 numTokens = tokens.length;\\n\\n        scalingFactors = new uint256[](numTokens);\\n\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            scalingFactors[i] = _readScalingFactor(_tokenState[tokens[i]]);\\n        }\\n    }\\n\\n    function _getNormalizedWeight(IERC20 token) internal view override returns (uint256) {\\n        uint256 pctProgress = _calculateWeightChangeProgress();\\n        bytes32 tokenData = _getTokenData(token);\\n\\n        return _interpolateWeight(tokenData, pctProgress);\\n    }\\n\\n    function _getNormalizedWeights() internal view override returns (uint256[] memory normalizedWeights) {\\n        (IERC20[] memory tokens, , ) = getVault().getPoolTokens(getPoolId());\\n        uint256 numTokens = tokens.length;\\n\\n        normalizedWeights = new uint256[](numTokens);\\n\\n        uint256 pctProgress = _calculateWeightChangeProgress();\\n\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            bytes32 tokenData = _tokenState[tokens[i]];\\n\\n            normalizedWeights[i] = _interpolateWeight(tokenData, pctProgress);\\n        }\\n    }\\n\\n    function _getNormalizedWeightsAndMaxWeightIndex()\\n        internal\\n        view\\n        override\\n        returns (uint256[] memory normalizedWeights, uint256 maxWeightTokenIndex)\\n    {\\n        normalizedWeights = _getNormalizedWeights();\\n\\n        maxWeightTokenIndex = 0;\\n        uint256 maxNormalizedWeight = normalizedWeights[0];\\n\\n        for (uint256 i = 1; i < normalizedWeights.length; i++) {\\n            if (normalizedWeights[i] > maxNormalizedWeight) {\\n                maxWeightTokenIndex = i;\\n                maxNormalizedWeight = normalizedWeights[i];\\n            }\\n        }\\n    }\\n\\n    // Swap overrides - revert unless swaps are enabled\\n\\n    function _onSwapGivenIn(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) internal view override returns (uint256) {\\n        _require(getSwapEnabled(), Errors.SWAPS_DISABLED);\\n\\n        return super._onSwapGivenIn(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\\n    }\\n\\n    function _onSwapGivenOut(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) internal view override returns (uint256) {\\n        _require(getSwapEnabled(), Errors.SWAPS_DISABLED);\\n\\n        return super._onSwapGivenOut(swapRequest, currentBalanceTokenIn, currentBalanceTokenOut);\\n    }\\n\\n    /**\\n     * @dev Used to adjust balances by subtracting all collected fees from them, as if they had been withdrawn from the\\n     * Vault.\\n     */\\n    function _subtractCollectedFees(uint256[] memory balances) private view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            // We can use unchecked getters as we know the map has the same size (and order!) as the Pool's tokens.\\n            balances[i] = balances[i].sub(_tokenCollectedManagementFees.unchecked_valueAt(i));\\n        }\\n    }\\n\\n    // We override _onJoinPool and _onExitPool as we need to not compute the current invariant and calculate protocol\\n    // fees, since that mechanism does not work for Pools in which the weights change over time. Instead, this Pool\\n    // always pays zero protocol fees.\\n    // Additionally, we also check that only non-swap join and exit kinds are allowed while swaps are disabled.\\n\\n    function getLastInvariant() public pure override returns (uint256) {\\n        _revert(Errors.UNHANDLED_BY_MANAGED_POOL);\\n    }\\n\\n    function _onJoinPool(\\n        bytes32,\\n        address sender,\\n        address,\\n        uint256[] memory balances,\\n        uint256,\\n        uint256,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        override\\n        whenNotPaused // All joins are disabled while the contract is paused.\\n        returns (\\n            uint256 bptAmountOut,\\n            uint256[] memory amountsIn,\\n            uint256[] memory dueProtocolFeeAmounts\\n        )\\n    {\\n        // If swaps are disabled, the only join kind that is allowed is the proportional one, as all others involve\\n        // implicit swaps and alter token prices.\\n        _require(\\n            getSwapEnabled() || userData.joinKind() == WeightedPoolUserData.JoinKind.ALL_TOKENS_IN_FOR_EXACT_BPT_OUT,\\n            Errors.INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED\\n        );\\n        // Check allowlist for LPs, if applicable\\n        _require(isAllowedAddress(sender), Errors.ADDRESS_NOT_ALLOWLISTED);\\n\\n        _subtractCollectedFees(balances);\\n\\n        (bptAmountOut, amountsIn) = _doJoin(balances, _getNormalizedWeights(), scalingFactors, userData);\\n        dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\\n    }\\n\\n    function _onExitPool(\\n        bytes32,\\n        address sender,\\n        address,\\n        uint256[] memory balances,\\n        uint256,\\n        uint256,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        override\\n        returns (\\n            uint256 bptAmountIn,\\n            uint256[] memory amountsOut,\\n            uint256[] memory dueProtocolFeeAmounts\\n        )\\n    {\\n        // Exits are not completely disabled while the contract is paused: proportional exits (exact BPT in for tokens\\n        // out) remain functional.\\n\\n        // If swaps are disabled, the only exit kind that is allowed is the proportional one (as all others involve\\n        // implicit swaps and alter token prices) and management fee collection (as there's no point in restricting\\n        // that).\\n        WeightedPoolUserData.ExitKind kind = userData.exitKind();\\n        _require(\\n            getSwapEnabled() ||\\n                kind == WeightedPoolUserData.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT ||\\n                kind == WeightedPoolUserData.ExitKind.MANAGEMENT_FEE_TOKENS_OUT,\\n            Errors.INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED\\n        );\\n\\n        _subtractCollectedFees(balances);\\n\\n        (bptAmountIn, amountsOut) = _doManagedPoolExit(\\n            sender,\\n            balances,\\n            _getNormalizedWeights(),\\n            scalingFactors,\\n            userData\\n        );\\n        dueProtocolFeeAmounts = new uint256[](_getTotalTokens());\\n    }\\n\\n    function _doManagedPoolExit(\\n        address sender,\\n        uint256[] memory balances,\\n        uint256[] memory normalizedWeights,\\n        uint256[] memory scalingFactors,\\n        bytes memory userData\\n    ) internal returns (uint256, uint256[] memory) {\\n        WeightedPoolUserData.ExitKind kind = userData.exitKind();\\n\\n        if (kind == WeightedPoolUserData.ExitKind.MANAGEMENT_FEE_TOKENS_OUT) {\\n            return _exitManagerFeeTokensOut(sender);\\n        } else {\\n            return _doExit(balances, normalizedWeights, scalingFactors, userData);\\n        }\\n    }\\n\\n    function _exitManagerFeeTokensOut(address sender)\\n        private\\n        whenNotPaused\\n        returns (uint256 bptAmountIn, uint256[] memory amountsOut)\\n    {\\n        // This exit function is disabled if the contract is paused.\\n\\n        // This exit function can only be called by the Pool itself - the authorization logic that governs when that\\n        // call can be made resides in withdrawCollectedManagementFees.\\n        _require(sender == address(this), Errors.UNAUTHORIZED_EXIT);\\n\\n        // Since what we're doing is sending out collected management fees, we don't require any BPT in exchange: we\\n        // simply send those funds over.\\n        bptAmountIn = 0;\\n\\n        amountsOut = new uint256[](_getTotalTokens());\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            // We can use unchecked getters and setters as we know the map has the same size (and order!) as the Pool's\\n            // tokens.\\n            amountsOut[i] = _tokenCollectedManagementFees.unchecked_valueAt(i);\\n            _tokenCollectedManagementFees.unchecked_setAt(i, 0);\\n        }\\n    }\\n\\n    function _tokenAddressToIndex(IERC20 token) internal view override returns (uint256) {\\n        return _tokenCollectedManagementFees.indexOf(token, Errors.INVALID_TOKEN);\\n    }\\n\\n    function _processSwapFeeAmount(uint256 index, uint256 amount) internal virtual override {\\n        if (amount > 0) {\\n            uint256 managementFeeAmount = amount.mulDown(_managementSwapFeePercentage);\\n\\n            uint256 previousCollectedFees = _tokenCollectedManagementFees.unchecked_valueAt(index);\\n            _tokenCollectedManagementFees.unchecked_setAt(index, previousCollectedFees.add(managementFeeAmount));\\n        }\\n\\n        super._processSwapFeeAmount(index, amount);\\n    }\\n\\n    // Pool swap hook override - subtract collected fees from all token amounts. We do this here as the original\\n    // `onSwap` does quite a bit of work, including computing swap fees, so we need to intercept that.\\n\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) public override returns (uint256) {\\n        uint256 tokenInUpscaledCollectedFees = _tokenCollectedManagementFees.get(\\n            swapRequest.tokenIn,\\n            Errors.INVALID_TOKEN\\n        );\\n        uint256 adjustedBalanceTokenIn = currentBalanceTokenIn.sub(\\n            _downscaleDown(tokenInUpscaledCollectedFees, _scalingFactor(swapRequest.tokenIn))\\n        );\\n\\n        uint256 tokenOutUpscaledCollectedFees = _tokenCollectedManagementFees.get(\\n            swapRequest.tokenOut,\\n            Errors.INVALID_TOKEN\\n        );\\n        uint256 adjustedBalanceTokenOut = currentBalanceTokenOut.sub(\\n            _downscaleDown(tokenOutUpscaledCollectedFees, _scalingFactor(swapRequest.tokenOut))\\n        );\\n\\n        return super.onSwap(swapRequest, adjustedBalanceTokenIn, adjustedBalanceTokenOut);\\n    }\\n\\n    /**\\n     * @dev When calling updateWeightsGradually again during an update, reset the start weights to the current weights,\\n     * if necessary. Time travel elements commented out.\\n     */\\n    function _startGradualWeightChange(\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256[] memory startWeights,\\n        uint256[] memory endWeights,\\n        IERC20[] memory tokens\\n    ) internal virtual {\\n        uint256 normalizedSum = 0;\\n        bytes32 tokenState;\\n\\n        for (uint256 i = 0; i < endWeights.length; i++) {\\n            uint256 endWeight = endWeights[i];\\n            _require(endWeight >= WeightedMath._MIN_WEIGHT, Errors.MIN_WEIGHT);\\n\\n            IERC20 token = tokens[i];\\n\\n            // Tokens with more than 18 decimals are not supported\\n            // Scaling calculations must be exact/lossless\\n            // Store decimal difference instead of actual scaling factor\\n            _tokenState[token] = tokenState\\n                .insertUint64(startWeights[i].compress64(), _START_WEIGHT_OFFSET)\\n                .insertUint32(endWeight.compress32(), _END_WEIGHT_OFFSET)\\n                .insertUint5(uint256(18).sub(ERC20(address(token)).decimals()), _DECIMAL_DIFF_OFFSET);\\n\\n            normalizedSum = normalizedSum.add(endWeight);\\n        }\\n        // Ensure that the normalized weights sum to ONE\\n        _require(normalizedSum == FixedPoint.ONE, Errors.NORMALIZED_WEIGHT_INVARIANT);\\n\\n        _setMiscData(\\n            _getMiscData().insertUint32(startTime, _START_TIME_OFFSET).insertUint32(endTime, _END_TIME_OFFSET)\\n        );\\n\\n        emit GradualWeightUpdateScheduled(startTime, endTime, startWeights, endWeights);\\n    }\\n\\n    function _readScalingFactor(bytes32 tokenState) private pure returns (uint256) {\\n        uint256 decimalsDifference = tokenState.decodeUint5(_DECIMAL_DIFF_OFFSET);\\n\\n        return FixedPoint.ONE * 10**decimalsDifference;\\n    }\\n\\n    /**\\n     * @dev Extend ownerOnly functions to include the Managed Pool control functions.\\n     */\\n    function _isOwnerOnlyAction(bytes32 actionId) internal view override returns (bool) {\\n        return\\n            (actionId == getActionId(ManagedPool.updateWeightsGradually.selector)) ||\\n            (actionId == getActionId(ManagedPool.setSwapEnabled.selector)) ||\\n            (actionId == getActionId(ManagedPool.withdrawCollectedManagementFees.selector)) ||\\n            (actionId == getActionId(ManagedPool.addAllowedAddress.selector)) ||\\n            (actionId == getActionId(ManagedPool.removeAllowedAddress.selector)) ||\\n            (actionId == getActionId(ManagedPool.setMustAllowlistLPs.selector)) ||\\n            super._isOwnerOnlyAction(actionId);\\n    }\\n\\n    /**\\n     * @dev Returns a fixed-point number representing how far along the current weight change is, where 0 means the\\n     * change has not yet started, and FixedPoint.ONE means it has fully completed.\\n     */\\n    function _calculateWeightChangeProgress() private view returns (uint256) {\\n        uint256 currentTime = block.timestamp;\\n        bytes32 poolState = _getMiscData();\\n\\n        uint256 startTime = poolState.decodeUint32(_START_TIME_OFFSET);\\n        uint256 endTime = poolState.decodeUint32(_END_TIME_OFFSET);\\n\\n        if (currentTime >= endTime) {\\n            return FixedPoint.ONE;\\n        } else if (currentTime <= startTime) {\\n            return 0;\\n        }\\n\\n        uint256 totalSeconds = endTime - startTime;\\n        uint256 secondsElapsed = currentTime - startTime;\\n\\n        // In the degenerate case of a zero duration change, consider it completed (and avoid division by zero)\\n        return secondsElapsed.divDown(totalSeconds);\\n    }\\n\\n    function _interpolateWeight(bytes32 tokenData, uint256 pctProgress) private pure returns (uint256 finalWeight) {\\n        uint256 startWeight = tokenData.decodeUint64(_START_WEIGHT_OFFSET).uncompress64();\\n        uint256 endWeight = tokenData.decodeUint32(_END_WEIGHT_OFFSET).uncompress32();\\n\\n        if (pctProgress == 0 || startWeight == endWeight) return startWeight;\\n        if (pctProgress >= FixedPoint.ONE) return endWeight;\\n\\n        if (startWeight > endWeight) {\\n            uint256 weightDelta = pctProgress.mulDown(startWeight - endWeight);\\n            return startWeight - weightDelta;\\n        } else {\\n            uint256 weightDelta = pctProgress.mulDown(endWeight - startWeight);\\n            return startWeight + weightDelta;\\n        }\\n    }\\n\\n    function _getTokenData(IERC20 token) private view returns (bytes32 tokenData) {\\n        tokenData = _tokenState[token];\\n\\n        // A valid token can't be zero (must have non-zero weights)\\n        _require(tokenData != 0, Errors.INVALID_TOKEN);\\n    }\\n}\\n\",\"keccak256\":\"0x22fbe03c47cb977c112122c65928ac9106fc4dcc76f77bf7539f61019e759707\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/pool-weighted/contracts/smart/WeightCompression.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../../solidity-utils/contracts/math/FixedPoint.sol\\\";\\n\\n/**\\n * @dev Library for compressing and uncompresing numbers by using smaller types.\\n * All values are 18 decimal fixed-point numbers in the [0.0, 1.0] range,\\n * so heavier compression (fewer bits) results in fewer decimals.\\n */\\nlibrary WeightCompression {\\n    uint256 private constant _UINT31_MAX = 2**(31) - 1;\\n\\n    using FixedPoint for uint256;\\n\\n    /**\\n     * @dev Convert a 16-bit value to full FixedPoint\\n     */\\n    function uncompress16(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(FixedPoint.ONE).divUp(type(uint16).max);\\n    }\\n\\n    /**\\n     * @dev Compress a FixedPoint value to 16 bits\\n     */\\n    function compress16(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(type(uint16).max).divUp(FixedPoint.ONE);\\n    }\\n\\n    /**\\n     * @dev Convert a 31-bit value to full FixedPoint\\n     */\\n    function uncompress31(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(FixedPoint.ONE).divUp(_UINT31_MAX);\\n    }\\n\\n    /**\\n     * @dev Compress a FixedPoint value to 31 bits\\n     */\\n    function compress31(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(_UINT31_MAX).divUp(FixedPoint.ONE);\\n    }\\n\\n    /**\\n     * @dev Convert a 32-bit value to full FixedPoint\\n     */\\n    function uncompress32(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(FixedPoint.ONE).divUp(type(uint32).max);\\n    }\\n\\n    /**\\n     * @dev Compress a FixedPoint value to 32 bits\\n     */\\n    function compress32(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(type(uint32).max).divUp(FixedPoint.ONE);\\n    }\\n\\n    /**\\n     * @dev Convert a 64-bit value to full FixedPoint\\n     */\\n    function uncompress64(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(FixedPoint.ONE).divUp(type(uint64).max);\\n    }\\n\\n    /**\\n     * @dev Compress a FixedPoint value to 64 bits\\n     */\\n    function compress64(uint256 value) internal pure returns (uint256) {\\n        return value.mulUp(type(uint64).max).divUp(FixedPoint.ONE);\\n    }\\n}\\n\",\"keccak256\":\"0xf5db86731d3e7bf8429c80ee0cc7dcd012f717f17a7050079f407167e7825afb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/Authentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./IAuthentication.sol\\\";\\n\\n/**\\n * @dev Building block for performing access control on external functions.\\n *\\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\\n * to external functions to only make them callable by authorized accounts.\\n *\\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\\n */\\nabstract contract Authentication is IAuthentication {\\n    bytes32 private immutable _actionIdDisambiguator;\\n\\n    /**\\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\\n     * multi contract systems.\\n     *\\n     * There are two main uses for it:\\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\\n     *    unique. The contract's own address is a good option.\\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\\n     *    shared by the entire family (and no other contract) should be used instead.\\n     */\\n    constructor(bytes32 actionIdDisambiguator) {\\n        _actionIdDisambiguator = actionIdDisambiguator;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\\n     */\\n    modifier authenticate() {\\n        _authenticateCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call the entry point function.\\n     */\\n    function _authenticateCaller() internal view {\\n        bytes32 actionId = getActionId(msg.sig);\\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\\n    }\\n\\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\\n        // multiple contracts.\\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\\n    }\\n\\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xea892213ec2967f53e26a0dd833bde01e4d9b6e49dd91e6c59ff00044f83c28d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/BalancerErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n// solhint-disable\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n */\\nfunction _require(bool condition, uint256 errorCode) pure {\\n    if (!condition) _revert(errorCode);\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n */\\nfunction _revert(uint256 errorCode) pure {\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\n    // 'BAL#{errorCode}'\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n    //\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n    // number (8 to 16 bits) than the individual string characters.\\n    //\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n    assembly {\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n        // the '0' character.\\n\\n        let units := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let tenths := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n        // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n        // characters to it, each shifted by a multiple of 8.\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n        // array).\\n\\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n        // message will have the following layout:\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n        // The string length is fixed: 7 characters.\\n        mstore(0x24, 7)\\n        // Finally, the string itself is stored.\\n        mstore(0x44, revertReason)\\n\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n        revert(0, 100)\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\\n    uint256 internal constant INVALID_INITIALIZATION = 342;\\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\\n    uint256 internal constant UNAUTHORIZED_OPERATION = 344;\\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n    uint256 internal constant NOT_PAUSED = 431;\\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n}\\n\",\"keccak256\":\"0xc9fd86f03fa1434694dd42eddd0d9e4cb3289ef143cae5ea977b86d5e95ad41d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/BaseSplitCodeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./CodeDeployer.sol\\\";\\n\\n/**\\n * @dev Base factory for contracts whose creation code is so large that the factory cannot hold it. This happens when\\n * the contract's creation code grows close to 24kB.\\n *\\n * Note that this factory cannot help with contracts that have a *runtime* (deployed) bytecode larger than 24kB.\\n */\\nabstract contract BaseSplitCodeFactory {\\n    // The contract's creation code is stored as code in two separate addresses, and retrieved via `extcodecopy`. This\\n    // means this factory supports contracts with creation code of up to 48kB.\\n    // We rely on inline-assembly to achieve this, both to make the entire operation highly gas efficient, and because\\n    // `extcodecopy` is not available in Solidity.\\n\\n    // solhint-disable no-inline-assembly\\n\\n    address private immutable _creationCodeContractA;\\n    uint256 private immutable _creationCodeSizeA;\\n\\n    address private immutable _creationCodeContractB;\\n    uint256 private immutable _creationCodeSizeB;\\n\\n    /**\\n     * @dev The creation code of a contract Foo can be obtained inside Solidity with `type(Foo).creationCode`.\\n     */\\n    constructor(bytes memory creationCode) {\\n        uint256 creationCodeSize = creationCode.length;\\n\\n        // We are going to deploy two contracts: one with approximately the first half of `creationCode`'s contents\\n        // (A), and another with the remaining half (B).\\n        // We store the lengths in both immutable and stack variables, since immutable variables cannot be read during\\n        // construction.\\n        uint256 creationCodeSizeA = creationCodeSize / 2;\\n        _creationCodeSizeA = creationCodeSizeA;\\n\\n        uint256 creationCodeSizeB = creationCodeSize - creationCodeSizeA;\\n        _creationCodeSizeB = creationCodeSizeB;\\n\\n        // To deploy the contracts, we're going to use `CodeDeployer.deploy()`, which expects a memory array with\\n        // the code to deploy. Note that we cannot simply create arrays for A and B's code by copying or moving\\n        // `creationCode`'s contents as they are expected to be very large (> 24kB), so we must operate in-place.\\n\\n        // Memory: [ code length ] [ A.data ] [ B.data ]\\n\\n        // Creating A's array is simple: we simply replace `creationCode`'s length with A's length. We'll later restore\\n        // the original length.\\n\\n        bytes memory creationCodeA;\\n        assembly {\\n            creationCodeA := creationCode\\n            mstore(creationCodeA, creationCodeSizeA)\\n        }\\n\\n        // Memory: [ A.length ] [ A.data ] [ B.data ]\\n        //         ^ creationCodeA\\n\\n        _creationCodeContractA = CodeDeployer.deploy(creationCodeA);\\n\\n        // Creating B's array is a bit more involved: since we cannot move B's contents, we are going to create a 'new'\\n        // memory array starting at A's last 32 bytes, which will be replaced with B's length. We'll back-up this last\\n        // byte to later restore it.\\n\\n        bytes memory creationCodeB;\\n        bytes32 lastByteA;\\n\\n        assembly {\\n            // `creationCode` points to the array's length, not data, so by adding A's length to it we arrive at A's\\n            // last 32 bytes.\\n            creationCodeB := add(creationCode, creationCodeSizeA)\\n            lastByteA := mload(creationCodeB)\\n            mstore(creationCodeB, creationCodeSizeB)\\n        }\\n\\n        // Memory: [ A.length ] [ A.data[ : -1] ] [ B.length ][ B.data ]\\n        //         ^ creationCodeA                ^ creationCodeB\\n\\n        _creationCodeContractB = CodeDeployer.deploy(creationCodeB);\\n\\n        // We now restore the original contents of `creationCode` by writing back the original length and A's last byte.\\n        assembly {\\n            mstore(creationCodeA, creationCodeSize)\\n            mstore(creationCodeB, lastByteA)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the two addresses where the creation code of the contract crated by this factory is stored.\\n     */\\n    function getCreationCodeContracts() public view returns (address contractA, address contractB) {\\n        return (_creationCodeContractA, _creationCodeContractB);\\n    }\\n\\n    /**\\n     * @dev Returns the creation code of the contract this factory creates.\\n     */\\n    function getCreationCode() public view returns (bytes memory) {\\n        return _getCreationCodeWithArgs(\\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the creation code that will result in a contract being deployed with `constructorArgs`.\\n     */\\n    function _getCreationCodeWithArgs(bytes memory constructorArgs) private view returns (bytes memory code) {\\n        // This function exists because `abi.encode()` cannot be instructed to place its result at a specific address.\\n        // We need for the ABI-encoded constructor arguments to be located immediately after the creation code, but\\n        // cannot rely on `abi.encodePacked()` to perform concatenation as that would involve copying the creation code,\\n        // which would be prohibitively expensive.\\n        // Instead, we compute the creation code in a pre-allocated array that is large enough to hold *both* the\\n        // creation code and the constructor arguments, and then copy the ABI-encoded arguments (which should not be\\n        // overly long) right after the end of the creation code.\\n\\n        // Immutable variables cannot be used in assembly, so we store them in the stack first.\\n        address creationCodeContractA = _creationCodeContractA;\\n        uint256 creationCodeSizeA = _creationCodeSizeA;\\n        address creationCodeContractB = _creationCodeContractB;\\n        uint256 creationCodeSizeB = _creationCodeSizeB;\\n\\n        uint256 creationCodeSize = creationCodeSizeA + creationCodeSizeB;\\n        uint256 constructorArgsSize = constructorArgs.length;\\n\\n        uint256 codeSize = creationCodeSize + constructorArgsSize;\\n\\n        assembly {\\n            // First, we allocate memory for `code` by retrieving the free memory pointer and then moving it ahead of\\n            // `code` by the size of the creation code plus constructor arguments, and 32 bytes for the array length.\\n            code := mload(0x40)\\n            mstore(0x40, add(code, add(codeSize, 32)))\\n\\n            // We now store the length of the code plus constructor arguments.\\n            mstore(code, codeSize)\\n\\n            // Next, we concatenate the creation code stored in A and B.\\n            let dataStart := add(code, 32)\\n            extcodecopy(creationCodeContractA, dataStart, 0, creationCodeSizeA)\\n            extcodecopy(creationCodeContractB, add(dataStart, creationCodeSizeA), 0, creationCodeSizeB)\\n        }\\n\\n        // Finally, we copy the constructorArgs to the end of the array. Unfortunately there is no way to avoid this\\n        // copy, as it is not possible to tell Solidity where to store the result of `abi.encode()`.\\n        uint256 constructorArgsDataPtr;\\n        uint256 constructorArgsCodeDataPtr;\\n        assembly {\\n            constructorArgsDataPtr := add(constructorArgs, 32)\\n            constructorArgsCodeDataPtr := add(add(code, 32), creationCodeSize)\\n        }\\n\\n        _memcpy(constructorArgsCodeDataPtr, constructorArgsDataPtr, constructorArgsSize);\\n    }\\n\\n    /**\\n     * @dev Deploys a contract with constructor arguments. To create `constructorArgs`, call `abi.encode()` with the\\n     * contract's constructor arguments, in order.\\n     */\\n    function _create(bytes memory constructorArgs) internal virtual returns (address) {\\n        bytes memory creationCode = _getCreationCodeWithArgs(constructorArgs);\\n\\n        address destination;\\n        assembly {\\n            destination := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        if (destination == address(0)) {\\n            // Bubble up inner revert reason\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        return destination;\\n    }\\n\\n    // From\\n    // https://github.com/Arachnid/solidity-stringutils/blob/b9a6f6615cf18a87a823cbc461ce9e140a61c305/src/strings.sol\\n    function _memcpy(\\n        uint256 dest,\\n        uint256 src,\\n        uint256 len\\n    ) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3e2981793763ecb3a1ddebaef556d0289d5415085392c28c51043a0d64e77c4e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/CodeDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Library used to deploy contracts with specific code. This can be used for long-term storage of immutable data as\\n * contract code, which can be retrieved via the `extcodecopy` opcode.\\n */\\nlibrary CodeDeployer {\\n    // During contract construction, the full code supplied exists as code, and can be accessed via `codesize` and\\n    // `codecopy`. This is not the contract's final code however: whatever the constructor returns is what will be\\n    // stored as its code.\\n    //\\n    // We use this mechanism to have a simple constructor that stores whatever is appended to it. The following opcode\\n    // sequence corresponds to the creation code of the following equivalent Solidity contract, plus padding to make the\\n    // full code 32 bytes long:\\n    //\\n    // contract CodeDeployer {\\n    //     constructor() payable {\\n    //         uint256 size;\\n    //         assembly {\\n    //             size := sub(codesize(), 32) // size of appended data, as constructor is 32 bytes long\\n    //             codecopy(0, 32, size) // copy all appended data to memory at position 0\\n    //             return(0, size) // return appended data for it to be stored as code\\n    //         }\\n    //     }\\n    // }\\n    //\\n    // More specifically, it is composed of the following opcodes (plus padding):\\n    //\\n    // [1] PUSH1 0x20\\n    // [2] CODESIZE\\n    // [3] SUB\\n    // [4] DUP1\\n    // [6] PUSH1 0x20\\n    // [8] PUSH1 0x00\\n    // [9] CODECOPY\\n    // [11] PUSH1 0x00\\n    // [12] RETURN\\n    //\\n    // The padding is just the 0xfe sequence (invalid opcode).\\n    bytes32\\n        private constant _DEPLOYER_CREATION_CODE = 0x602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe;\\n\\n    /**\\n     * @dev Deploys a contract with `code` as its code, returning the destination address.\\n     *\\n     * Reverts if deployment fails.\\n     */\\n    function deploy(bytes memory code) internal returns (address destination) {\\n        bytes32 deployerCreationCode = _DEPLOYER_CREATION_CODE;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let codeLength := mload(code)\\n\\n            // `code` is composed of length and data. We've already stored its length in `codeLength`, so we simply\\n            // replace it with the deployer creation code (which is exactly 32 bytes long).\\n            mstore(code, deployerCreationCode)\\n\\n            // At this point, `code` now points to the deployer creation code immediately followed by `code`'s data\\n            // contents. This is exactly what the deployer expects to receive when created.\\n            destination := create(0, code, add(codeLength, 32))\\n\\n            // Finally, we restore the original length in order to not mutate `code`.\\n            mstore(code, codeLength)\\n        }\\n\\n        // The create opcode returns the zero address when contract creation fails, so we revert if this happens.\\n        _require(destination != address(0), Errors.CODE_DEPLOYMENT_FAILED);\\n    }\\n}\\n\",\"keccak256\":\"0xfeb244ff55cfa33a17a1cef41ea065c651cb00f375d4139e1c6de805c7d9c17d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/ERC20Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../../vault/contracts/interfaces/IAsset.sol\\\";\\n\\nimport \\\"../openzeppelin/IERC20.sol\\\";\\n\\n// solhint-disable\\n\\nfunction _asIAsset(IERC20[] memory tokens) pure returns (IAsset[] memory assets) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n        assets := tokens\\n    }\\n}\\n\\nfunction _sortTokens(\\n    IERC20 tokenA,\\n    IERC20 tokenB,\\n    IERC20 tokenC\\n) pure returns (IERC20[] memory tokens) {\\n    (uint256 indexTokenA, uint256 indexTokenB, uint256 indexTokenC) = _getSortedTokenIndexes(tokenA, tokenB, tokenC);\\n    tokens = new IERC20[](3);\\n    tokens[indexTokenA] = tokenA;\\n    tokens[indexTokenB] = tokenB;\\n    tokens[indexTokenC] = tokenC;\\n}\\n\\nfunction _insertSorted(IERC20[] memory tokens, IERC20 token) pure returns (IERC20[] memory sorted) {\\n    sorted = new IERC20[](tokens.length + 1);\\n\\n    if (tokens.length == 0) {\\n        sorted[0] = token;\\n        return sorted;\\n    }\\n\\n    uint256 i;\\n    for (i = tokens.length; i > 0 && tokens[i - 1] > token; i--) sorted[i] = tokens[i - 1];\\n    for (uint256 j = 0; j < i; j++) sorted[j] = tokens[j];\\n    sorted[i] = token;\\n}\\n\\nfunction _getSortedTokenIndexes(\\n    IERC20 tokenA,\\n    IERC20 tokenB,\\n    IERC20 tokenC\\n)\\n    pure\\n    returns (\\n        uint256 indexTokenA,\\n        uint256 indexTokenB,\\n        uint256 indexTokenC\\n    )\\n{\\n    if (tokenA < tokenB) {\\n        if (tokenB < tokenC) {\\n            // (tokenA, tokenB, tokenC)\\n            return (0, 1, 2);\\n        } else if (tokenA < tokenC) {\\n            // (tokenA, tokenC, tokenB)\\n            return (0, 2, 1);\\n        } else {\\n            // (tokenC, tokenA, tokenB)\\n            return (1, 2, 0);\\n        }\\n    } else {\\n        // tokenB < tokenA\\n        if (tokenC < tokenB) {\\n            // (tokenC, tokenB, tokenA)\\n            return (2, 1, 0);\\n        } else if (tokenC < tokenA) {\\n            // (tokenB, tokenC, tokenA)\\n            return (2, 0, 1);\\n        } else {\\n            // (tokenB, tokenA, tokenC)\\n            return (1, 0, 2);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc47ad45aa3a4f6f5118eb1b092de06c01efe890b0f736e76a41e2d7eddbfe488\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/IAuthentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAuthentication {\\n    /**\\n     * @dev Returns the action identifier associated with the external function described by `selector`.\\n     */\\n    function getActionId(bytes4 selector) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xfd687ced203d2c6da8189792e1719a5182faf45956129388b231ee76740b99a6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/ISignaturesValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\\n */\\ninterface ISignaturesValidator {\\n    /**\\n     * @dev Returns the EIP712 domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the next nonce used by an address to sign messages.\\n     */\\n    function getNextNonce(address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2fe46b13b7c8bfc6f5c539c0b73d6325813f383f551b71fb6bca8dafd06964e1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/ITemporarilyPausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface for the TemporarilyPausable helper.\\n */\\ninterface ITemporarilyPausable {\\n    /**\\n     * @dev Emitted every time the pause state changes by `_setPaused`.\\n     */\\n    event PausedStateChanged(bool paused);\\n\\n    /**\\n     * @dev Returns the current paused state.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        );\\n}\\n\",\"keccak256\":\"0xb3e5b7c63f80b80ef3f0138eac56c397a439bf6b667fc06d5061aa869828b562\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/InputHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../openzeppelin/IERC20.sol\\\";\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nlibrary InputHelpers {\\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\\n        _require(a == b, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureInputLengthMatch(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure {\\n        _require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(address[] memory array) internal pure {\\n        if (array.length < 2) {\\n            return;\\n        }\\n\\n        address previous = array[0];\\n        for (uint256 i = 1; i < array.length; ++i) {\\n            address current = array[i];\\n            _require(previous < current, Errors.UNSORTED_ARRAY);\\n            previous = current;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9899df7be5dfd3e2dd686140de070594c1882ac78529ca8cb2848fc7ddbdcf2e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/TemporarilyPausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./ITemporarilyPausable.sol\\\";\\n\\n/**\\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\\n * used as an emergency switch in case a security vulnerability or threat is identified.\\n *\\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\\n * analysis later determines there was a false alarm.\\n *\\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\\n *\\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\\n * irreversible.\\n */\\nabstract contract TemporarilyPausable is ITemporarilyPausable {\\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\\n    // solhint-disable not-rely-on-time\\n\\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\\n\\n    uint256 private immutable _pauseWindowEndTime;\\n    uint256 private immutable _bufferPeriodEndTime;\\n\\n    bool private _paused;\\n\\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\\n        _require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\\n        _require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\\n\\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\\n\\n        _pauseWindowEndTime = pauseWindowEndTime;\\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    modifier whenNotPaused() {\\n        _ensureNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\\n     * Period.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        override\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        )\\n    {\\n        paused = !_isNotPaused();\\n        pauseWindowEndTime = _getPauseWindowEndTime();\\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\\n    }\\n\\n    /**\\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\\n     * unpaused until the end of the Buffer Period.\\n     *\\n     * Once the Buffer Period expires, this function reverts unconditionally.\\n     */\\n    function _setPaused(bool paused) internal {\\n        if (paused) {\\n            _require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\\n        } else {\\n            _require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\\n        }\\n\\n        _paused = paused;\\n        emit PausedStateChanged(paused);\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    function _ensureNotPaused() internal view {\\n        _require(_isNotPaused(), Errors.PAUSED);\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not paused.\\n     */\\n    function _ensurePaused() internal view {\\n        _require(!_isNotPaused(), Errors.NOT_PAUSED);\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is unpaused.\\n     *\\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\\n     * longer accessed.\\n     */\\n    function _isNotPaused() internal view returns (bool) {\\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\\n    }\\n\\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\\n\\n    function _getPauseWindowEndTime() private view returns (uint256) {\\n        return _pauseWindowEndTime;\\n    }\\n\\n    function _getBufferPeriodEndTime() private view returns (uint256) {\\n        return _bufferPeriodEndTime;\\n    }\\n}\\n\",\"keccak256\":\"0xc2f8afde456420ea386c4456cfcb8f5cbc526dd78dd06dfe7ed229a122e316d9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/helpers/WordCodec.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for encoding and decoding values stored inside a 256 bit word. Typically used to pack multiple values in\\n * a single storage slot, saving gas by performing less storage accesses.\\n *\\n * Each value is defined by its size and the least significant bit in the word, also known as offset. For example, two\\n * 128 bit values may be encoded in a word by assigning one an offset of 0, and the other an offset of 128.\\n *\\n * We could use Solidity structs to pack values together in a single storage slot instead of relying on a custom and\\n * error-prone library, but unfortunately Solidity only allows for structs to live in either storage, calldata or\\n * memory. Because a memory struct uses not just memory but also a slot in the stack (to store its memory location),\\n * using memory for word-sized values (i.e. of 256 bits or less) is strictly less gas performant, and doesn't even\\n * prevent stack-too-deep issues. This is compounded by the fact that Balancer contracts typically are memory-intensive,\\n * and the cost of accesing memory increases quadratically with the number of allocated words. Manual packing and\\n * unpacking is therefore the preferred approach.\\n */\\nlibrary WordCodec {\\n    // Masks are values with the least significant N bits set. They can be used to extract an encoded value from a word,\\n    // or to insert a new one replacing the old.\\n    uint256 private constant _MASK_1 = 2**(1) - 1;\\n    uint256 private constant _MASK_5 = 2**(5) - 1;\\n    uint256 private constant _MASK_7 = 2**(7) - 1;\\n    uint256 private constant _MASK_10 = 2**(10) - 1;\\n    uint256 private constant _MASK_16 = 2**(16) - 1;\\n    uint256 private constant _MASK_22 = 2**(22) - 1;\\n    uint256 private constant _MASK_31 = 2**(31) - 1;\\n    uint256 private constant _MASK_32 = 2**(32) - 1;\\n    uint256 private constant _MASK_53 = 2**(53) - 1;\\n    uint256 private constant _MASK_64 = 2**(64) - 1;\\n    uint256 private constant _MASK_96 = 2**(96) - 1;\\n    uint256 private constant _MASK_128 = 2**(128) - 1;\\n    uint256 private constant _MASK_192 = 2**(192) - 1;\\n\\n    // Largest positive values that can be represented as N bits signed integers.\\n    int256 private constant _MAX_INT_22 = 2**(21) - 1;\\n    int256 private constant _MAX_INT_53 = 2**(52) - 1;\\n\\n    // In-place insertion\\n\\n    /**\\n     * @dev Inserts a boolean value shifted by an offset into a 256 bit word, replacing the old value. Returns the new\\n     * word.\\n     */\\n    function insertBool(\\n        bytes32 word,\\n        bool value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_1 << offset));\\n        return clearedWord | bytes32(uint256(value ? 1 : 0) << offset);\\n    }\\n\\n    // Unsigned\\n\\n    /**\\n     * @dev Inserts a 5 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 5 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint5(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_5 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 7 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 7 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint7(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_7 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 10 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 10 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint10(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_10 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 16 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value.\\n     * Returns the new word.\\n     *\\n     * Assumes `value` only uses its least significant 16 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint16(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_16 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 31 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` can be represented using 31 bits.\\n     */\\n    function insertUint31(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_31 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 32 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 32 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint32(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_32 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    /**\\n     * @dev Inserts a 64 bit unsigned integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` only uses its least significant 64 bits, otherwise it may overwrite sibling bytes.\\n     */\\n    function insertUint64(\\n        bytes32 word,\\n        uint256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_64 << offset));\\n        return clearedWord | bytes32(value << offset);\\n    }\\n\\n    // Signed\\n\\n    /**\\n     * @dev Inserts a 22 bits signed integer shifted by an offset into a 256 bit word, replacing the old value. Returns\\n     * the new word.\\n     *\\n     * Assumes `value` can be represented using 22 bits.\\n     */\\n    function insertInt22(\\n        bytes32 word,\\n        int256 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_22 << offset));\\n        // Integer values need masking to remove the upper bits of negative values.\\n        return clearedWord | bytes32((uint256(value) & _MASK_22) << offset);\\n    }\\n\\n    // Bytes\\n\\n    /**\\n     * @dev Inserts 192 bit shifted by an offset into a 256 bit word, replacing the old value. Returns the new word.\\n     *\\n     * Assumes `value` can be represented using 192 bits.\\n     */\\n    function insertBits192(\\n        bytes32 word,\\n        bytes32 value,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        bytes32 clearedWord = bytes32(uint256(word) & ~(_MASK_192 << offset));\\n        return clearedWord | bytes32((uint256(value) & _MASK_192) << offset);\\n    }\\n\\n    // Encoding\\n\\n    // Unsigned\\n\\n    /**\\n     * @dev Encodes an unsigned integer shifted by an offset. This performs no size checks: it is up to the caller to\\n     * ensure that the values are bounded.\\n     *\\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\\n     */\\n    function encodeUint(uint256 value, uint256 offset) internal pure returns (bytes32) {\\n        return bytes32(value << offset);\\n    }\\n\\n    // Signed\\n\\n    /**\\n     * @dev Encodes a 22 bits signed integer shifted by an offset.\\n     *\\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\\n     */\\n    function encodeInt22(int256 value, uint256 offset) internal pure returns (bytes32) {\\n        // Integer values need masking to remove the upper bits of negative values.\\n        return bytes32((uint256(value) & _MASK_22) << offset);\\n    }\\n\\n    /**\\n     * @dev Encodes a 53 bits signed integer shifted by an offset.\\n     *\\n     * The return value can be logically ORed with other encoded values to form a 256 bit word.\\n     */\\n    function encodeInt53(int256 value, uint256 offset) internal pure returns (bytes32) {\\n        // Integer values need masking to remove the upper bits of negative values.\\n        return bytes32((uint256(value) & _MASK_53) << offset);\\n    }\\n\\n    // Decoding\\n\\n    /**\\n     * @dev Decodes and returns a boolean shifted by an offset from a 256 bit word.\\n     */\\n    function decodeBool(bytes32 word, uint256 offset) internal pure returns (bool) {\\n        return (uint256(word >> offset) & _MASK_1) == 1;\\n    }\\n\\n    // Unsigned\\n\\n    /**\\n     * @dev Decodes and returns a 5 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint5(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_5;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 7 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint7(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_7;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 10 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint10(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_10;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 16 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint16(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_16;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 31 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint31(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_31;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 32 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint32(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_32;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 64 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint64(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_64;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 96 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint96(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_96;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 128 bit unsigned integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeUint128(bytes32 word, uint256 offset) internal pure returns (uint256) {\\n        return uint256(word >> offset) & _MASK_128;\\n    }\\n\\n    // Signed\\n\\n    /**\\n     * @dev Decodes and returns a 22 bits signed integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeInt22(bytes32 word, uint256 offset) internal pure returns (int256) {\\n        int256 value = int256(uint256(word >> offset) & _MASK_22);\\n        // In case the decoded value is greater than the max positive integer that can be represented with 22 bits,\\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\\n        // representation.\\n        return value > _MAX_INT_22 ? (value | int256(~_MASK_22)) : value;\\n    }\\n\\n    /**\\n     * @dev Decodes and returns a 53 bits signed integer shifted by an offset from a 256 bit word.\\n     */\\n    function decodeInt53(bytes32 word, uint256 offset) internal pure returns (int256) {\\n        int256 value = int256(uint256(word >> offset) & _MASK_53);\\n        // In case the decoded value is greater than the max positive integer that can be represented with 53 bits,\\n        // we know it was originally a negative integer. Therefore, we mask it to restore the sign in the 256 bit\\n        // representation.\\n\\n        return value > _MAX_INT_53 ? (value | int256(~_MASK_53)) : value;\\n    }\\n}\\n\",\"keccak256\":\"0x3d0f1e120aff921b527945f2e5b0cb9d6711535005dfe5219097c93b5210d810\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0x38720507bb6c838df83953d1ffa88b97d0e06baefa0e3e387303cb8a090a49f5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/math/LogExpMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \\u201cSoftware\\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \\u201cAS IS\\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            // We solve the 0^0 indetermination by making it equal one.\\n            return uint256(ONE_18);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n        // x^y = exp(y * ln(x)).\\n\\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n        int256 x_int256 = int256(x);\\n\\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n        int256 y_int256 = int256(y);\\n\\n        int256 logx_times_y;\\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n            int256 ln_36_x = _ln_36(x_int256);\\n\\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n            // (downscaled) last 18 decimals.\\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n        } else {\\n            logx_times_y = _ln(x_int256) * y_int256;\\n        }\\n        logx_times_y /= ONE_18;\\n\\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n        _require(\\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n            Errors.PRODUCT_OUT_OF_BOUNDS\\n        );\\n\\n        return uint256(exp(logx_times_y));\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n\\n        if (x < 0) {\\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n            // Fixed point division requires multiplying by ONE_18.\\n            return ((ONE_18 * ONE_18) / exp(-x));\\n        }\\n\\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n        // decomposition.\\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest x_n.\\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n        // decomposition.\\n\\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n        // it and compute the accumulated product.\\n\\n        int256 firstAN;\\n        if (x >= x0) {\\n            x -= x0;\\n            firstAN = a0;\\n        } else if (x >= x1) {\\n            x -= x1;\\n            firstAN = a1;\\n        } else {\\n            firstAN = 1; // One with no decimal places\\n        }\\n\\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n        // smaller terms.\\n        x *= 100;\\n\\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n        int256 product = ONE_20;\\n\\n        if (x >= x2) {\\n            x -= x2;\\n            product = (product * a2) / ONE_20;\\n        }\\n        if (x >= x3) {\\n            x -= x3;\\n            product = (product * a3) / ONE_20;\\n        }\\n        if (x >= x4) {\\n            x -= x4;\\n            product = (product * a4) / ONE_20;\\n        }\\n        if (x >= x5) {\\n            x -= x5;\\n            product = (product * a5) / ONE_20;\\n        }\\n        if (x >= x6) {\\n            x -= x6;\\n            product = (product * a6) / ONE_20;\\n        }\\n        if (x >= x7) {\\n            x -= x7;\\n            product = (product * a7) / ONE_20;\\n        }\\n        if (x >= x8) {\\n            x -= x8;\\n            product = (product * a8) / ONE_20;\\n        }\\n        if (x >= x9) {\\n            x -= x9;\\n            product = (product * a9) / ONE_20;\\n        }\\n\\n        // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n        // The first term is simply x.\\n        term = x;\\n        seriesSum += term;\\n\\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n        term = ((term * x) / ONE_20) / 2;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 3;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 4;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 5;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 6;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 7;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 8;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 9;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 10;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 11;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 12;\\n        seriesSum += term;\\n\\n        // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n        // and then drop two digits to return an 18 decimal value.\\n\\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n        // upscaling.\\n\\n        int256 logBase;\\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n            logBase = _ln_36(base);\\n        } else {\\n            logBase = _ln(base) * ONE_18;\\n        }\\n\\n        int256 logArg;\\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n            logArg = _ln_36(arg);\\n        } else {\\n            logArg = _ln(arg) * ONE_18;\\n        }\\n\\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n        return (logArg * ONE_18) / logBase;\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        // The real natural logarithm is not defined for negative numbers or zero.\\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n            return _ln_36(a) / ONE_18;\\n        } else {\\n            return _ln(a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        if (a < ONE_18) {\\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n            // Fixed point division requires multiplying by ONE_18.\\n            return (-_ln((ONE_18 * ONE_18) / a));\\n        }\\n\\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest a_n.\\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n        // ONE_18 to convert them to fixed point.\\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n        // by it and compute the accumulated sum.\\n\\n        int256 sum = 0;\\n        if (a >= a0 * ONE_18) {\\n            a /= a0; // Integer, not fixed point division\\n            sum += x0;\\n        }\\n\\n        if (a >= a1 * ONE_18) {\\n            a /= a1; // Integer, not fixed point division\\n            sum += x1;\\n        }\\n\\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n        sum *= 100;\\n        a *= 100;\\n\\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n        if (a >= a2) {\\n            a = (a * ONE_20) / a2;\\n            sum += x2;\\n        }\\n\\n        if (a >= a3) {\\n            a = (a * ONE_20) / a3;\\n            sum += x3;\\n        }\\n\\n        if (a >= a4) {\\n            a = (a * ONE_20) / a4;\\n            sum += x4;\\n        }\\n\\n        if (a >= a5) {\\n            a = (a * ONE_20) / a5;\\n            sum += x5;\\n        }\\n\\n        if (a >= a6) {\\n            a = (a * ONE_20) / a6;\\n            sum += x6;\\n        }\\n\\n        if (a >= a7) {\\n            a = (a * ONE_20) / a7;\\n            sum += x7;\\n        }\\n\\n        if (a >= a8) {\\n            a = (a * ONE_20) / a8;\\n            sum += x8;\\n        }\\n\\n        if (a >= a9) {\\n            a = (a * ONE_20) / a9;\\n            sum += x9;\\n        }\\n\\n        if (a >= a10) {\\n            a = (a * ONE_20) / a10;\\n            sum += x10;\\n        }\\n\\n        if (a >= a11) {\\n            a = (a * ONE_20) / a11;\\n            sum += x11;\\n        }\\n\\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n        // Let z = (a - 1) / (a + 1).\\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n        // division by ONE_20.\\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n        int256 z_squared = (z * z) / ONE_20;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 11;\\n\\n        // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n        seriesSum *= 2;\\n\\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n        // value.\\n\\n        return (sum + seriesSum) / 100;\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n        // worthwhile.\\n\\n        // First, we transform x to a 36 digit fixed point value.\\n        x *= ONE_18;\\n\\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n        // division by ONE_36.\\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n        int256 z_squared = (z * z) / ONE_36;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 11;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 13;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 15;\\n\\n        // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // All that remains is multiplying by 2 (non fixed point).\\n        return seriesSum * 2;\\n    }\\n}\\n\",\"keccak256\":\"0x66c6a4efc58bcc18d11fdc3236ec53f6044944918e86116f3aa3deee1daac8ef\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the absolute value of a signed integer.\\n     */\\n    function abs(int256 a) internal pure returns (uint256) {\\n        return a > 0 ? uint256(a) : uint256(-a);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\\n        return c;\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        return roundUp ? divUp(a, b) : divDown(a, b);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x29c458d7fb857d1d3c07ef1bf28d54255b6dfca0a80fd5f51316770054bc40db\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/misc/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../openzeppelin/IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for WETH9.\\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\\n */\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x19a0628bedbe48178a4c90509a40d750d5039677b964ec533a24361a8d97274b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _HASHED_NAME = keccak256(bytes(name));\\n        _HASHED_VERSION = keccak256(bytes(version));\\n        _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparatorV4(), structHash));\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        // Silence state mutability warning without generating bytecode.\\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\\n        // https://github.com/ethereum/solidity/issues/2691\\n        this;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0cf3ec5d6130aac057e69df14b1ff87baf9c6c2cb13bc545952def004e629ac0\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            msg.sender,\\n            _allowances[sender][msg.sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].sub(subtractedValue, Errors.ERC20_DECREASED_ALLOWANCE_BELOW_ZERO)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        _require(sender != address(0), Errors.ERC20_TRANSFER_FROM_ZERO_ADDRESS);\\n        _require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_BALANCE);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _require(account != address(0), Errors.ERC20_BURN_FROM_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x4bd56e87f0041ba666a540160962cd9f1eed11164a9a91af180550d69da4c8bc\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/ERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./EIP712.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    mapping(address => uint256) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        // solhint-disable-next-line not-rely-on-time\\n        _require(block.timestamp <= deadline, Errors.EXPIRED_PERMIT);\\n\\n        uint256 nonce = _nonces[owner];\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        _require((signer != address(0)) && (signer == owner), Errors.INVALID_SIGNATURE);\\n\\n        _nonces[owner] = nonce + 1;\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view override returns (uint256) {\\n        return _nonces[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n}\\n\",\"keccak256\":\"0x28f96497e4b653b5ae3b3f1f34ce749dab19c1034304f77398c4958e8af7e900\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Based on the EnumerableMap library from OpenZeppelin Contracts, altered to include the following:\\n//  * a map from IERC20 to bytes32\\n//  * entries are stored in mappings instead of arrays, reducing implicit storage reads for out-of-bounds checks\\n//  * unchecked_at and unchecked_valueAt, which allow for more gas efficient data reads in some scenarios\\n//  * indexOf, unchecked_indexOf and unchecked_setAt, which allow for more gas efficient data writes in some scenarios\\n//\\n// Additionally, the base private functions that work on bytes32 were removed and replaced with a native implementation\\n// for IERC20 keys, to reduce bytecode size and runtime costs.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n */\\nlibrary EnumerableMap {\\n    // The original OpenZeppelin implementation uses a generic Map type with bytes32 keys: this was replaced with\\n    // IERC20ToBytes32Map and IERC20ToUint256Map, resulting in more dense bytecode (as long as each contract only uses\\n    // one of these - there'll otherwise be duplicated code).\\n\\n    // IERC20ToBytes32Map\\n\\n    struct IERC20ToBytes32MapEntry {\\n        IERC20 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct IERC20ToBytes32Map {\\n        // Number of entries in the map\\n        uint256 _length;\\n        // Storage of map keys and values\\n        mapping(uint256 => IERC20ToBytes32MapEntry) _entries;\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping(IERC20 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to !contains(map, key)\\n        if (keyIndex == 0) {\\n            uint256 previousLength = map._length;\\n            map._entries[previousLength] = IERC20ToBytes32MapEntry({ _key: key, _value: value });\\n            map._length = previousLength + 1;\\n\\n            // The entry is stored at previousLength, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = previousLength + 1;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_setAt(\\n        IERC20ToBytes32Map storage map,\\n        uint256 index,\\n        bytes32 value\\n    ) internal {\\n        map._entries[index]._value = value;\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(IERC20ToBytes32Map storage map, IERC20 key) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to contains(map, key)\\n        if (keyIndex != 0) {\\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the pseudo-array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._length - 1;\\n\\n            // The swap is only necessary if we're not removing the last element\\n            if (toDeleteIndex != lastIndex) {\\n                IERC20ToBytes32MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n                // Move the last entry to the index where the entry to delete is\\n                map._entries[toDeleteIndex] = lastEntry;\\n                // Update the index for the moved entry\\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the slot where the moved entry was stored\\n            delete map._entries[lastIndex];\\n            map._length = lastIndex;\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(IERC20ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._length;\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\\n        return unchecked_at(map, index);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\\n     * than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\\n        IERC20ToBytes32MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function unchecked_valueAt(IERC20ToBytes32Map storage map, uint256 index) internal view returns (bytes32) {\\n        return map._entries[index]._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\\n     */\\n    function get(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (bytes32) {\\n        uint256 index = map._indexes[key];\\n        _require(index > 0, errorCode);\\n        return unchecked_valueAt(map, index - 1);\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`.\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function indexOf(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (uint256) {\\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\\n        _require(uncheckedIndex != 0, errorCode);\\n        return uncheckedIndex - 1;\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\\n     * instead.\\n     */\\n    function unchecked_indexOf(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (uint256) {\\n        return map._indexes[key];\\n    }\\n\\n    // IERC20ToUint256Map\\n\\n    struct IERC20ToUint256MapEntry {\\n        IERC20 _key;\\n        uint256 _value;\\n    }\\n\\n    struct IERC20ToUint256Map {\\n        // Number of entries in the map\\n        uint256 _length;\\n        // Storage of map keys and values\\n        mapping(uint256 => IERC20ToUint256MapEntry) _entries;\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping(IERC20 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        IERC20ToUint256Map storage map,\\n        IERC20 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to !contains(map, key)\\n        if (keyIndex == 0) {\\n            uint256 previousLength = map._length;\\n            map._entries[previousLength] = IERC20ToUint256MapEntry({ _key: key, _value: value });\\n            map._length = previousLength + 1;\\n\\n            // The entry is stored at previousLength, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = previousLength + 1;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via\\n     * {unchecked_indexOf}, and it should be noted that key indices may change when calling {set} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_setAt(\\n        IERC20ToUint256Map storage map,\\n        uint256 index,\\n        uint256 value\\n    ) internal {\\n        map._entries[index]._value = value;\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(IERC20ToUint256Map storage map, IERC20 key) internal returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to contains(map, key)\\n        if (keyIndex != 0) {\\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the pseudo-array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._length - 1;\\n\\n            // The swap is only necessary if we're not removing the last element\\n            if (toDeleteIndex != lastIndex) {\\n                IERC20ToUint256MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n                // Move the last entry to the index where the entry to delete is\\n                map._entries[toDeleteIndex] = lastEntry;\\n                // Update the index for the moved entry\\n                map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the slot where the moved entry was stored\\n            delete map._entries[lastIndex];\\n            map._length = lastIndex;\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(IERC20ToUint256Map storage map, IERC20 key) internal view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(IERC20ToUint256Map storage map) internal view returns (uint256) {\\n        return map._length;\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\\n        _require(map._length > index, Errors.OUT_OF_BOUNDS);\\n        return unchecked_at(map, index);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is equal or larger\\n     * than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(IERC20ToUint256Map storage map, uint256 index) internal view returns (IERC20, uint256) {\\n        IERC20ToUint256MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_At}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function unchecked_valueAt(IERC20ToUint256Map storage map, uint256 index) internal view returns (uint256) {\\n        return map._entries[index]._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map. Reverts with `errorCode` otherwise.\\n     */\\n    function get(\\n        IERC20ToUint256Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (uint256) {\\n        uint256 index = map._indexes[key];\\n        _require(index > 0, errorCode);\\n        return unchecked_valueAt(map, index - 1);\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`.\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function indexOf(\\n        IERC20ToUint256Map storage map,\\n        IERC20 key,\\n        uint256 errorCode\\n    ) internal view returns (uint256) {\\n        uint256 uncheckedIndex = unchecked_indexOf(map, key);\\n        _require(uncheckedIndex != 0, errorCode);\\n        return uncheckedIndex - 1;\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key` **plus one**. Does not revert if the key is not in the map, and returns 0\\n     * instead.\\n     */\\n    function unchecked_indexOf(IERC20ToUint256Map storage map, IERC20 key) internal view returns (uint256) {\\n        return map._indexes[key];\\n    }\\n}\\n\",\"keccak256\":\"0x39aa7d995cb42943bb568b3406432e7a9d2146e61e5770eb6e8d11976c32f7ee\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xd828a935a72a6d182912abba290e4debb8c684c36fd756088f7acb30e0b2bb76\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xffe929ce55ef0cbdcc60eee8bc9375c295757ad13afe3d757646538aa0429ff5\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce bytecode size.\\n// Modifier code is inlined by the compiler, which causes its code to appear multiple times in the codebase. By using\\n// private functions, we achieve the same end result with slightly higher runtime gas costs, but reduced bytecode size.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _enterNonReentrant();\\n        _;\\n        _exitNonReentrant();\\n    }\\n\\n    function _enterNonReentrant() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        _require(_status != _ENTERED, Errors.REENTRANCY);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _exitNonReentrant() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xfe6da463cd5a6df10b49020a69b0978a4ef65d029e747c515062ec4a3359c464\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/solidity-utils/contracts/openzeppelin/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, Errors.SUB_OVERFLOW);\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\\n        _require(b <= a, errorCode);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xafe0542eb14932a66ce6280fbe9991130ead5bbcb7836d0a822fc4a59810c100\",\"license\":\"MIT\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IAsset.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\",\"keccak256\":\"0x70ecf1d48c285d78718bd2e159345677038ed8a81c74444bedd6a5c61af9aff6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IAuthorizer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorizer {\\n    /**\\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\\n     */\\n    function canPerform(\\n        bytes32 actionId,\\n        address account,\\n        address where\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x792871e208bba1dad291f8d1cffad86f4afa5e2360816bd9c43481f7297155f5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IBasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IPoolSwapStructs.sol\\\";\\n\\n/**\\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\\n * either IGeneralPool or IMinimalSwapInfoPool\\n */\\ninterface IBasePool is IPoolSwapStructs {\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\\n     * The Vault will then take tokens from `sender` and add them to the Pool's balances, as well as collect\\n     * the reported amount in protocol fees, which the pool should calculate based on `protocolSwapFeePercentage`.\\n     *\\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\\n     *\\n     * `sender` is the account performing the join (from which tokens will be withdrawn), and `recipient` is the account\\n     * designated to receive any benefits (typically pool shares). `balances` contains the total balances\\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\\n     * balance.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as minting pool shares.\\n     */\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\\n\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\\n     * tokens the Vault should deduct from the Pool's balances, as well as the amount of protocol fees the Pool owes\\n     * to the Vault. The Vault will then take tokens from the Pool's balances and send them to `recipient`,\\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on\\n     * `protocolSwapFeePercentage`.\\n     *\\n     * Protocol fees are charged on exit events to guarantee that users exiting the Pool have paid their share.\\n     *\\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\\n     * to which the Vault will send the proceeds. `balances` contains the total token balances for each token\\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `lastChangeBlock` is the last block in which *any* of the Pool's registered tokens last changed its total\\n     * balance.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as burning pool shares.\\n     */\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\\n\\n    function getPoolId() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xceae7edca5dc3084127b998c4a5b4c8a01e00777484fb19fcc4d5199adc7f826\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IFlashLoanRecipient.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"../../../solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x14a7770525d059993696fe3f8f16a660890c2286a54cd12274343956552c5ab2\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IMinimalSwapInfoPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IBasePool.sol\\\";\\n\\n/**\\n * @dev Pool contracts with the MinimalSwapInfo or TwoToken specialization settings should implement this interface.\\n *\\n * This is called by the Vault when a user calls `IVault.swap` or `IVault.batchSwap` to swap with this Pool.\\n * Returns the number of tokens the Pool will grant to the user in a 'given in' swap, or that the user will grant\\n * to the pool in a 'given out' swap.\\n *\\n * This can often be implemented by a `view` function, since many pricing algorithms don't need to track state\\n * changes in swaps. However, contracts implementing this in non-view functions should check that the caller is\\n * indeed the Vault.\\n */\\ninterface IMinimalSwapInfoPool is IBasePool {\\n    function onSwap(\\n        SwapRequest memory swapRequest,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) external returns (uint256 amount);\\n}\\n\",\"keccak256\":\"0x7469919e147c0db8b4f290d310ca3816dec5d3c6cc6b258cf6e0df820a20a179\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IPoolSwapStructs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPoolSwapStructs {\\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\\n    // IMinimalSwapInfoPool.\\n    //\\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type ('given in' or\\n    // 'given out') which indicates whether or not the amount sent by the pool is known.\\n    //\\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\\n    //\\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\\n    // some Pools.\\n    //\\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\\n    // one Pool.\\n    //\\n    // The meaning of `lastChangeBlock` depends on the Pool specialization:\\n    //  - Two Token or Minimal Swap Info: the last block in which either `tokenIn` or `tokenOut` changed its total\\n    //    balance.\\n    //  - General: the last block in which *any* of the Pool's registered tokens changed its total balance.\\n    //\\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\\n    // where the Pool sends the outgoing tokens.\\n    //\\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\\n    struct SwapRequest {\\n        IVault.SwapKind kind;\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amount;\\n        // Misc data\\n        bytes32 poolId;\\n        uint256 lastChangeBlock;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n}\\n\",\"keccak256\":\"0x8ff8977dffe8122c5970976cae22478876de8d1242d44c702b3acf7cb2de97c8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IProtocolFeesCollector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\n\\ninterface IProtocolFeesCollector {\\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\\n\\n    function withdrawCollectedFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external;\\n\\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\\n\\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\\n\\n    function getSwapFeePercentage() external view returns (uint256);\\n\\n    function getFlashLoanFeePercentage() external view returns (uint256);\\n\\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\\n\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    function vault() external view returns (IVault);\\n}\\n\",\"keccak256\":\"0xc9c9aef7581329c240a2b04603345a5fac3c6e13aea9c6ec98a6237ca046bac0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/dependencies/balancer-labs/vault/contracts/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\nimport \\\"../../../solidity-utils/contracts/helpers/ISignaturesValidator.sol\\\";\\nimport \\\"../../../solidity-utils/contracts/helpers/ITemporarilyPausable.sol\\\";\\nimport \\\"../../../solidity-utils/contracts/misc/IWETH.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\nimport \\\"./IProtocolFeesCollector.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault is ISignaturesValidator, ITemporarilyPausable {\\n    // Generalities about the Vault:\\n    //\\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n    //\\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n    //\\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n    // Authorizer\\n    //\\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n    // can perform a given action.\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n     *\\n     * Emits an `AuthorizerChanged` event.\\n     */\\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    /**\\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\\n     */\\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\\n\\n    // Relayers\\n    //\\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n    // this power, two things must occur:\\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n    //    functions.\\n    //  - Each user must approve the relayer to act on their behalf.\\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n    /**\\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n     */\\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n    /**\\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n     *\\n     * Emits a `RelayerApprovalChanged` event.\\n     */\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\\n     */\\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n    //\\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n    // operations of different kinds, with different senders and recipients, at once.\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IAsset asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    // There are four possible operations in `manageUserBalance`:\\n    //\\n    // - DEPOSIT_INTERNAL\\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n    // relevant for relayers).\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - WITHDRAW_INTERNAL\\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n    // it to the recipient as ETH.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_INTERNAL\\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_EXTERNAL\\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n    // relayers, as it lets them reuse a user's Vault allowance.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `ExternalBalanceTransfer` event.\\n\\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\\n\\n    /**\\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n    /**\\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n    // Pools\\n    //\\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n    // functionality:\\n    //\\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n    // which increase with the number of registered tokens.\\n    //\\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n    // independent of the number of registered tokens.\\n    //\\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\\n\\n    /**\\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n    /**\\n     * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n    /**\\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\\n\\n    /**\\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        );\\n\\n    /**\\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    /**\\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        IERC20[] tokens,\\n        int256[] deltas,\\n        uint256[] protocolFeeAmounts\\n    );\\n\\n    enum PoolBalanceChangeKind { JOIN, EXIT }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n    // the final intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n     * for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n     * `receiveFlashLoan` call.\\n     *\\n     * Emits `FlashLoan` events.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\\n     */\\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\\n\\n    // Asset Management\\n    //\\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n    //\\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n    //\\n    // This concept is unrelated to the IAsset interface.\\n\\n    /**\\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\\n     *\\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\\n     * operations of different kinds, with different Pools and tokens, at once.\\n     *\\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\\n     */\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n    struct PoolBalanceOp {\\n        PoolBalanceOpKind kind;\\n        bytes32 poolId;\\n        IERC20 token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n     *\\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n     *\\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n     */\\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\\n\\n    /**\\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\\n     */\\n    event PoolBalanceManaged(\\n        bytes32 indexed poolId,\\n        address indexed assetManager,\\n        IERC20 indexed token,\\n        int256 cashDelta,\\n        int256 managedDelta\\n    );\\n\\n    // Protocol Fees\\n    //\\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\\n    // permissioned accounts.\\n    //\\n    // There are two kinds of protocol fees:\\n    //\\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\\n    //\\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\\n    // exiting a Pool in debt without first paying their share.\\n\\n    /**\\n     * @dev Returns the current protocol fee module.\\n     */\\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\\n\\n    /**\\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\\n     * error in some part of the system.\\n     *\\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\\n     *\\n     * While the contract is paused, the following features are disabled:\\n     * - depositing and transferring internal balance\\n     * - transferring external balance (using the Vault's allowance)\\n     * - swaps\\n     * - joining Pools\\n     * - Asset Manager interactions\\n     *\\n     * Internal Balance can still be withdrawn, and Pools exited.\\n     */\\n    function setPaused(bool paused) external;\\n\\n    /**\\n     * @dev Returns the Vault's WETH instance.\\n     */\\n    function WETH() external view returns (IWETH);\\n    // solhint-disable-previous-line func-name-mixedcase\\n}\\n\",\"keccak256\":\"0xaf892b41ff9b1e0864b8960b4cf551e80648ddd91112bb754dea4db2afe41bff\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x6101406040523480156200001257600080fd5b5060405162007d0438038062007d048339810160408190526200003591620001c3565b80604051806020016200004890620001b5565b601f1982820381018352601f909101166040528051819060006002820460a081905280830360e0819052818552909150836200009081620000f9602090811b620002fe17901c565b60601b6001600160601b0319166080528285018051838252620000bf82620000f9602090811b620002fe17901c565b6001600160601b0319606091821b811660c0529690935290529590951b90911661010052505050426276a700016101205250620001f39050565b80517f602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe808352600091602081018484f09084529150620001476001600160a01b03831615156101ac6200014d565b50919050565b816200015e576200015e8162000162565b5050565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b616e3d8062000ec783390190565b600060208284031215620001d5578081fd5b81516001600160a01b0381168114620001ec578182fd5b9392505050565b60805160601c60a05160c05160601c60e0516101005160601c61012051610c726200025560003980610173528061019c52508061020452508061036552508061014a52806103e152508061038652508061012952806103bd5250610c726000f3fe608060405234801561001057600080fd5b50600436106100715760003560e01c80636634b753116100505780636634b753146100c05780638d928af8146100e0578063a7c671eb146100f557610071565b8062c194db14610076578063174481fa146100945780632da47c40146100aa575b600080fd5b61007e610108565b60405161008b9190610a73565b60405180910390f35b61009c610127565b60405161008b929190610a41565b6100b261016d565b60405161008b929190610bc2565b6100d36100ce3660046107e6565b6101d7565b60405161008b9190610a68565b6100e8610202565b60405161008b9190610a20565b6100e8610103366004610802565b610226565b60606101226040518060200160405280600081525061035d565b905090565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000009091565b600080427f00000000000000000000000000000000000000000000000000000000000000008110156101c957807f000000000000000000000000000000000000000000000000000000000000000003925062278d0091506101d2565b60009250600091505b509091565b73ffffffffffffffffffffffffffffffffffffffff1660009081526020819052604090205460ff1690565b7f000000000000000000000000000000000000000000000000000000000000000090565b600080600061023361016d565b915091506102ed604051806101a0016040528061024e610202565b73ffffffffffffffffffffffffffffffffffffffff1681526020018f81526020018e81526020018d81526020018c81526020018b81526020018a81526020018481526020018381526020018973ffffffffffffffffffffffffffffffffffffffff16815260200188151581526020018715158152602001868152506040516020016102d99190610a86565b604051602081830303815290604052610436565b9d9c50505050505050505050505050565b80517f602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe808352600091602081018484f0908452915061035773ffffffffffffffffffffffffffffffffffffffff831615156101ac6104c1565b50919050565b8051604080517f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000818101858101848101602090810190965280855293957f00000000000000000000000000000000000000000000000000000000000000009592947f000000000000000000000000000000000000000000000000000000000000000094938801866000828a3c846000888301883c50602089810190898501016104288183866104d3565b505050505050505050919050565b6000806104428361054d565b73ffffffffffffffffffffffffffffffffffffffff811660008181526020819052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790555192935090917f83a48fbcfc991335314e74d0496aab6a1987e992ddc85dddbcc4d6dd6ef2e9fc9190a292915050565b816104cf576104cf81610595565b5050565b5b602081106105115781518352602092830192909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0016104d4565b905182516020929092036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169116179052565b6000606061055a8361035d565b905060008151602083016000f0905073ffffffffffffffffffffffffffffffffffffffff811661058e573d6000803e3d6000fd5b9392505050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b803561060d81610c17565b92915050565b600082601f830112610623578081fd5b813561063661063182610bf7565b610bd0565b81815291506020808301908481018184028601820187101561065757600080fd5b60005b8481101561067f57813561066d81610c17565b8452928201929082019060010161065a565b505050505092915050565b600082601f83011261069a578081fd5b81356106a861063182610bf7565b8181529150602080830190848101818402860182018710156106c957600080fd5b60005b8481101561067f5781356106df81610c17565b845292820192908201906001016106cc565b600082601f830112610701578081fd5b813561070f61063182610bf7565b81815291506020808301908481018184028601820187101561073057600080fd5b60005b8481101561067f57813584529282019290820190600101610733565b8035801515811461060d57600080fd5b600082601f83011261076f578081fd5b813567ffffffffffffffff811115610785578182fd5b6107b660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610bd0565b91508082528360208285010111156107cd57600080fd5b8060208401602084013760009082016020015292915050565b6000602082840312156107f7578081fd5b813561058e81610c17565b6000806000806000806000806000806101408b8d031215610821578586fd5b8a3567ffffffffffffffff80821115610838578788fd5b6108448e838f0161075f565b9b5060208d0135915080821115610859578788fd5b6108658e838f0161075f565b9a5060408d013591508082111561087a578788fd5b6108868e838f0161068a565b995060608d013591508082111561089b578788fd5b6108a78e838f016106f1565b985060808d01359150808211156108bc578788fd5b506108c98d828e01610613565b96505060a08b013594506108e08c60c08d01610602565b93506108ef8c60e08d0161074f565b92506108ff8c6101008d0161074f565b91506101208b013590509295989b9194979a5092959850565b73ffffffffffffffffffffffffffffffffffffffff169052565b6000815180845260208085019450808401835b8381101561097757815173ffffffffffffffffffffffffffffffffffffffff1687529582019590820190600101610945565b509495945050505050565b6000815180845260208085019450808401835b8381101561097757815187529582019590820190600101610995565b15159052565b60008151808452815b818110156109dc576020818501810151868301820152016109c0565b818111156109ed5782602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff92831681529116602082015260400190565b901515815260200190565b60006020825261058e60208301846109b7565b600060208252610a9a602083018451610918565b60208301516101a0806040850152610ab66101c08501836109b7565b915060408501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe080868503016060870152610af284836109b7565b93506060870151915080868503016080870152610b0f8483610932565b935060808701519150808685030160a0870152610b2c8483610982565b935060a08701519150808685030160c087015250610b4a8382610932565b92505060c085015160e085015260e0850151610100818187015280870151915050610120818187015280870151915050610140610b8981870183610918565b8601519050610160610b9d868201836109b1565b8601519050610180610bb1868201836109b1565b959095015193019290925250919050565b918252602082015260400190565b60405181810167ffffffffffffffff81118282101715610bef57600080fd5b604052919050565b600067ffffffffffffffff821115610c0d578081fd5b5060209081020190565b73ffffffffffffffffffffffffffffffffffffffff81168114610c3957600080fd5b5056fea264697066735822122019d43b0379102538042b144e1f9d289867affe41ec2bd8deb1d36ae9a389efeb64736f6c634300070100336101e06040527f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9610120523480156200003757600080fd5b5060405162006e3d38038062006e3d8339810160408190526200005a9162000ec7565b805160208201516040830151606084015160a085015160c086015160e0870151610100880151610120890151855189906002146200009a5760016200009d565b60025b8989898989898989828289898d8280604051806040016040528060018152602001603160f81b81525085858a336001600160a01b031660001b806080818152505050806001600160a01b031660a0816001600160a01b031660601b815250505081600390805190602001906200011592919062000c0f565b5080516200012b90600490602084019062000c0f565b505060058054601260ff1990911617905550815160209283012060c052805191012060e052507f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6101005260601b6001600160601b03191661014052506200019e90506276a70083111561019462000495565b620001b262278d0082111561019562000495565b4290910161016081905201610180528551620001d4906002111560c862000495565b620001ee620001e2620004aa565b8751111560c962000495565b6200020486620004af60201b620016181760201c565b6200020f84620004bb565b6040516309b2760f60e01b81526000906001600160a01b038c16906309b2760f9062000240908d9060040162001164565b602060405180830381600087803b1580156200025b57600080fd5b505af115801562000270573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000296919062000eae565b604051633354e3e960e11b81529091506001600160a01b038c16906366a9c7d290620002cb9084908b908b90600401620010c8565b600060405180830381600087803b158015620002e657600080fd5b505af1158015620002fb573d6000803e3d6000fd5b50505050806101a0818152505050505050505050505050505050505050505050506001600a819055506000816060015151905062000350818360800151518460a00151516200054760201b620016221760201c565b620003806200037a8260016200036562000567565b6200056d60201b6200163a179092919060201c565b62000580565b62000398816200038f620005a5565b1460c962000495565b620003bc670de0b6b3a764000083610180015111156101526200049560201b60201c565b608082015160608301514291620003d991839182918190620005d0565b60005b8281101562000425576200041b84606001518281518110620003fa57fe5b60200260200101516000600c6200081160201b62001649179092919060201c565b50600101620003dc565b506101408301516200043790620008c1565b61016083015162000448906200091c565b610180830180516101c052516040517feba99e9e36df79031493efd8473cfce5475d3a135878665490df8b014069321091620004849162001179565b60405180910390a15050506200122b565b81620004a657620004a68162000962565b5050565b603290565b80620004a681620009b5565b620004d064e8d4a5100082101560cb62000495565b620004e867016345785d8a000082111560ca62000495565b620005078160c060085462000a3f60201b62001716179092919060201c565b6008556040517fa9ba3ffe0b6c366b81232caab38605a0699ad5398d6cce76f91ee809e322dafc906200053c90839062001179565b60405180910390a150565b6200056282841480156200055a57508183145b606762000495565b505050565b60085490565b81811b607f821b198416175b9392505050565b6200059f81600060085462000a5460201b6200172c179092919060201c565b60085550565b6000620005cb6001620005b762000567565b62000a6f60201b620017581790919060201c565b905090565b600080805b845181101562000797576000858281518110620005ee57fe5b6020026020010151905062000616662386f26fc1000082101561012e6200049560201b60201c565b60008583815181106200062557fe5b6020026020010151905062000753620006c5826001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b1580156200067157600080fd5b505afa15801562000686573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620006ac91906200105e565b60ff16601262000a7c60201b6200175f1790919060201c565b60606200073e620006e18662000a9460201b620017751760201c565b604062000729620007118f8b81518110620006f857fe5b602002602001015162000ad760201b620017991760201c565b60008c62000a3f60201b62001716179092919060201c565b62000b0960201b620017b9179092919060201c565b62000b1b60201b620017cb179092919060201c565b6001600160a01b0382166000908152600b60209081526040909120919091556200078a9086908490620017da62000b2a821b17901c565b94505050600101620005d5565b50620007b0670de0b6b3a7640000831461013462000495565b620007c96200037a876028620007298b60088262000567565b7f0f3631f9dab08169d1db21c6dc5f32536fb2b0a6b9bb5330d71c52132f968be08787878760405162000800949392919062001182565b60405180910390a150505050505050565b6001600160a01b038216600090815260028401602052604081205480620008a057505082546040805180820182526001600160a01b03858116808352602080840187815260008781526001808c018452878220965187546001600160a01b0319169616959095178655905194840194909455948201808955908352600288019094529190209190915562000579565b60001901600090815260018086016020526040822001839055905062000579565b620008eb6200037a826000620008d662000567565b62000b3e60201b620017ec179092919060201c565b7f5a9e84f78f7957cb4ed7478eb0fcad35ee4ecbe2e0f298420b28a3955392573f816040516200053c9190620010bd565b620009316200037a826048620008d662000567565b7f5353e2cb47d505ba9b628610daec53fc41f3a4259dab35a757b0f1d5a58bc1c3816040516200053c9190620010bd565b62461bcd60e51b6000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b600281511015620009c65762000a3c565b600081600081518110620009d657fe5b602002602001015190506000600190505b82518110156200056257600083828151811062000a0057fe5b6020026020010151905062000a31816001600160a01b0316846001600160a01b03161060656200049560201b60201c565b9150600101620009e7565b50565b6001600160401b03811b1992909216911b1790565b6001600160c01b03828116821b90821b198416179392505050565b81811c607f165b92915050565b600062000a8e83831115600162000495565b50900390565b600062000a76670de0b6b3a764000062000ac363ffffffff80168562000b6760201b620018131790919060201c565b62000bbc60201b620018611790919060201c565b600062000a76670de0b6b3a764000062000ac36001600160401b0380168562000b6760201b620018131790919060201c565b63ffffffff811b1992909216911b1790565b601f811b1992909216911b1790565b600082820162000579848210158362000495565b60006001821b198416828462000b5657600062000b59565b60015b60ff16901b17949350505050565b600082820262000b8f84158062000b8757508385838162000b8457fe5b04145b600362000495565b8062000ba057600091505062000a76565b670de0b6b3a764000060001982015b0460010191505062000a76565b600062000bcd821515600462000495565b8262000bdc5750600062000a76565b670de0b6b3a76400008381029062000c029085838162000bf857fe5b0414600562000495565b82600182038162000baf57fe5b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1062000c5257805160ff191683800117855562000c82565b8280016001018555821562000c82579182015b8281111562000c8257825182559160200191906001019062000c65565b5062000c9092915062000c94565b5090565b5b8082111562000c90576000815560010162000c95565b805162000a768162001215565b600082601f83011262000cc9578081fd5b815162000ce062000cda82620011e9565b620011c2565b81815291506020808301908481018184028601820187101562000d0257600080fd5b60005b8481101562000d2e57815162000d1b8162001215565b8452928201929082019060010162000d05565b505050505092915050565b600082601f83011262000d4a578081fd5b815162000d5b62000cda82620011e9565b81815291506020808301908481018184028601820187101562000d7d57600080fd5b60005b8481101562000d2e57815162000d968162001215565b8452928201929082019060010162000d80565b600082601f83011262000dba578081fd5b815162000dcb62000cda82620011e9565b81815291506020808301908481018184028601820187101562000ded57600080fd5b60005b8481101562000d2e5781518452928201929082019060010162000df0565b8051801515811462000a7657600080fd5b600082601f83011262000e30578081fd5b81516001600160401b0381111562000e46578182fd5b602062000e5c601f8301601f19168201620011c2565b9250818352848183860101111562000e7357600080fd5b60005b8281101562000e9357848101820151848201830152810162000e76565b8281111562000ea55760008284860101525b50505092915050565b60006020828403121562000ec0578081fd5b5051919050565b60006020828403121562000ed9578081fd5b81516001600160401b038082111562000ef0578283fd5b81840191506101a080838703121562000f07578384fd5b62000f1281620011c2565b905062000f20868462000cab565b815260208301518281111562000f34578485fd5b62000f428782860162000e1f565b60208301525060408301518281111562000f5a578485fd5b62000f688782860162000e1f565b60408301525060608301518281111562000f80578485fd5b62000f8e8782860162000d39565b60608301525060808301518281111562000fa6578485fd5b62000fb48782860162000da9565b60808301525060a08301518281111562000fcc578485fd5b62000fda8782860162000cb8565b60a08301525060c083015160c082015260e083015160e0820152610100915081830151828201526101209150620010148683850162000cab565b8282015261014091506200102b8683850162000e0e565b828201526101609150620010428683850162000e0e565b9181019190915261018091820151918101919091529392505050565b60006020828403121562001070578081fd5b815160ff8116811462000579578182fd5b6000815180845260208085019450808401835b83811015620010b25781518752958201959082019060010162001094565b509495945050505050565b901515815260200190565b60006060820185835260206060818501528186518084526080860191508288019350845b81811015620011145762001101855162001209565b83529383019391830191600101620010ec565b505084810360408601528551808252908201925081860190845b81811015620011565762001143835162001209565b855293830193918301916001016200112e565b509298975050505050505050565b60208101600383106200117357fe5b91905290565b90815260200190565b600085825284602083015260806040830152620011a3608083018562001081565b8281036060840152620011b7818562001081565b979650505050505050565b6040518181016001600160401b0381118282101715620011e157600080fd5b604052919050565b60006001600160401b03821115620011ff578081fd5b5060209081020190565b6001600160a01b031690565b6001600160a01b038116811462000a3c57600080fd5b60805160a05160601c60c05160e05161010051610120516101405160601c61016051610180516101a0516101c051615b8b620012b2600039806110f952806137905250806108f9525080611a39525080611a155250806110d5525080611373525080611d34525080611d76525080611d555250806110a252508061102c5250615b8b6000f3fe608060405234801561001057600080fd5b506004361061030a5760003560e01c80637b749c451161019c57806395d89b41116100ee578063c0ff1a1511610097578063dd62ed3e11610071578063dd62ed3e14610605578063e01af92c14610618578063f89f27ed1461062b5761030a565b8063c0ff1a15146105d7578063d505accf146105df578063d5c096c4146105f25761030a565b8063a457c2d7116100c8578063a457c2d7146105a9578063a9059cbb146105bc578063aaabadc5146105cf5761030a565b806395d89b41146105865780639b02cdde1461058e5780639d2c110c146105965761030a565b8063851c1bb3116101505780638d0274661161012a5780638d0274661461056e5780638d928af81461057657806390605f3a1461057e5761030a565b8063851c1bb31461053357806387ec681714610546578063893d20e8146105595761030a565b80637ecebe00116101815780637ecebe00146104fa57806381788e2b1461050d5780638345245e146105205761030a565b80637b749c45146104d05780637beed220146104e35761030a565b806338fff2d01161026057806355c6762811610209578063679aefce116101e3578063679aefce1461049457806370a082311461049c57806374f3b009146104af5761030a565b806355c67628146104585780635b77155e146104605780636028bfd4146104735761030a565b80633e5692051161023a5780633e5692051461042a57806347bc4d921461043d57806350dd6ed9146104455761030a565b806338fff2d0146103fc57806339509351146104045780633c9d93b8146104175761030a565b80631dd746ea116102c257806332f144f51161029c57806332f144f5146103cb5780633644e515146103e157806338e9922e146103e95761030a565b80631dd746ea1461038e57806323b872dd146103a3578063313ce567146103b65761030a565b806316c38b3c116102f357806316c38b3c1461034d57806318160ddd146103625780631c0de051146103775761030a565b806306fdde031461030f578063095ea7b31461032d575b600080fd5b610317610633565b6040516103249190615a2e565b60405180910390f35b61034061033b36600461514c565b6106ca565b6040516103249190615834565b61036061035b366004615243565b6106e1565b005b61036a6106f5565b6040516103249190615857565b61037f6106fb565b6040516103249392919061583f565b610396610724565b60405161032491906157fc565b6103406103b136600461509c565b610733565b6103be6107a9565b6040516103249190615ab5565b6103d36107b2565b6040516103249291906157a6565b61036a6108d4565b6103606103f73660046155cf565b6108de565b61036a6108f7565b61034061041236600461514c565b61091b565b610360610425366004615048565b610956565b6103606104383660046155e7565b6109f5565b610340610af2565b61036061045336600461537a565b610b07565b61036a610b25565b61036061046e366004615048565b610b36565b61048661048136600461527b565b610c5d565b604051610324929190615a41565b61036a610c94565b61036a6104aa366004615048565b610cbf565b6104c26104bd36600461527b565b610cde565b60405161032492919061580f565b6103606104de366004615243565b610d81565b6104eb610d9a565b60405161032493929190615a5a565b61036a610508366004615048565b610f27565b61036061051b366004615048565b610f42565b61034061052e366004615048565b610ff8565b61036a61054136600461531e565b611028565b61048661055436600461527b565b61107a565b6105616110a0565b6040516103249190615792565b6103406110c4565b6105616110d3565b61036a6110f7565b61031761111b565b61036a61117c565b61036a6105a43660046154d3565b611189565b6103406105b736600461514c565b611224565b6103406105ca36600461514c565b611262565b61056161126f565b61036a611279565b6103606105ed3660046150dc565b61133e565b6104c261060036600461527b565b611487565b61036a610613366004615064565b6115b8565b610360610626366004615243565b6115f5565b61039661160e565b60038054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156106bf5780601f10610694576101008083540402835291602001916106bf565b820191906000526020600020905b8154815290600101906020018083116106a257829003601f168201915b505050505090505b90565b60006106d73384846118ac565b5060015b92915050565b6106e9611914565b6106f28161195a565b50565b60025490565b60008060006107086119f6565b159250610713611a13565b915061071d611a37565b9050909192565b606061072e611a5b565b905090565b60008061074085336115b8565b9050610764336001600160a01b038716148061075c5750838210155b61019e611ba8565b61076f858585611bb6565b336001600160a01b0386161480159061078a57506000198114155b1561079c5761079c85338584036118ac565b60019150505b9392505050565b60055460ff1690565b6060806107bd611c96565b67ffffffffffffffff811180156107d357600080fd5b506040519080825280602002602001820160405280156107fd578160200160208202803683370190505b509150610808611c96565b67ffffffffffffffff8111801561081e57600080fd5b50604051908082528060200260200182016040528015610848578160200160208202803683370190505b50905060005b610856611c96565b8110156108be5760008061086b600c84611cab565b915091508185848151811061087c57fe5b60200260200101906001600160a01b031690816001600160a01b031681525050808484815181106108a957fe5b6020908102919091010152505060010161084e565b506108d0816108cb611a5b565b611ccf565b9091565b600061072e611d30565b6108e6611914565b6108ee611dcd565b6106f281611de2565b7f000000000000000000000000000000000000000000000000000000000000000090565b3360008181526001602090815260408083206001600160a01b038716845290915281205490916106d791859061095190866117da565b6118ac565b61095e611914565b610966611dcd565b6001600160a01b0381166000908152600f602052604090205461098e9060ff166101b1611ba8565b6001600160a01b0381166000818152600f602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055517f89aa0423af0b4cf311bfb79f61549f2b82b335f041e4f7ae674618059b51a4cb9190a250565b6109fd611914565b610a05611dcd565b610a0d611e4d565b610a1f610a18611c96565b8251611e66565b42610a2a8185611e73565b9350610a3b83851115610146611ba8565b6060610a456110d3565b6001600160a01b031663f94d4668610a5b6108f7565b6040518263ffffffff1660e01b8152600401610a779190615857565b60006040518083038186803b158015610a8f57600080fd5b505afa158015610aa3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610acb9190810190615177565b50509050610ae38585610adc611e8a565b8685611feb565b5050610aed6121af565b505050565b600061072e6000610b016121b6565b906121bc565b610b0f611914565b610b17611dcd565b610b2182826121c6565b5050565b60085460009061072e9060c06122de565b610b3e611914565b610b46611dcd565b610b4e611e4d565b606080610b596107b2565b91509150610b656110d3565b6001600160a01b0316638bdb3913610b7b6108f7565b30866040518060800160405280610b91896106c7565b81526020018781526020016003604051602001610bae9190615a1a565b6040516020818303038152906040528152602001600015158152506040518563ffffffff1660e01b8152600401610be8949392919061587f565b600060405180830381600087803b158015610c0257600080fd5b505af1158015610c16573d6000803e3d6000fd5b505050507f5cf8dd4ddeaded21c5e3dc4043073fa7659089e0d11d8480344663008dff060f8282604051610c4b9291906157a6565b60405180910390a150506106f26121af565b60006060610c738651610c6e611c96565b611e66565b610c88898989898989896122ec611ccf6123b9565b97509795505050505050565b600061072e610ca16106f5565b610cb9610cac611279565b610cb4611c96565b612549565b90612563565b6001600160a01b0381166000908152602081905260409020545b919050565b60608088610d08610ced6110d3565b6001600160a01b0316336001600160a01b03161460cd611ba8565b610d1d610d136108f7565b82146101f4611ba8565b6060610d27611a5b565b9050610d3388826125ab565b6000606080610d488e8e8e8e8e8e8a8f6122ec565b925092509250610d588d8461260c565b610d628285611ccf565b610d6c8185611ccf565b909550935050505b5097509795505050505050565b610d89611914565b610d91611dcd565b6106f281612616565b60008060606000610da96121b6565b9050610db681600861265d565b9350610dc381602861265d565b92506060610dcf6110d3565b6001600160a01b031663f94d4668610de56108f7565b6040518263ffffffff1660e01b8152600401610e019190615857565b60006040518083038186803b158015610e1957600080fd5b505afa158015610e2d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610e559190810190615177565b505080519091508067ffffffffffffffff81118015610e7357600080fd5b50604051908082528060200260200182016040528015610e9d578160200160208202803683370190505b50935060005b81811015610f1e57610eff610efa6040600b6000878681518110610ec357fe5b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000205461265d90919063ffffffff16565b612667565b858281518110610f0b57fe5b6020908102919091010152600101610ea3565b50505050909192565b6001600160a01b031660009081526006602052604090205490565b610f4a611914565b610f52611dcd565b610f65610f5d6110c4565b610158611ba8565b6001600160a01b0381166000908152600f6020526040902054610f8e9060ff16156101b0611ba8565b6001600160a01b0381166000818152600f602052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055517fbf5840c727acdcaceea5154edc82998fa82a490aa3dc7aeb66849c8bbea1f5799190a250565b60006110026110c4565b15806106db5750506001600160a01b03166000908152600f602052604090205460ff1690565b60007f00000000000000000000000000000000000000000000000000000000000000008260405160200161105d92919061571c565b604051602081830303815290604052805190602001209050919050565b6000606061108b8651610c6e611c96565b610c88898989898989896126856127476123b9565b7f000000000000000000000000000000000000000000000000000000000000000090565b600061072e6048610b016121b6565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b60048054604080516020601f60026000196101006001881615020190951694909404938401819004810282018101909252828152606093909290918301828280156106bf5780601f10610694576101008083540402835291602001916106bf565b60006106c76101536127a8565b6000806111a88560200151610135600c6128159092919063ffffffff16565b905060006111cc6111c5836111c08960200151612852565b612865565b869061175f565b905060006111ec8760400151610135600c6128159092919063ffffffff16565b9050600061120b611204836111c08b60400151612852565b879061175f565b9050611218888483612871565b98975050505050505050565b60008061123133856115b8565b905080831061124b57611246338560006118ac565b611258565b61125833858584036118ac565b5060019392505050565b60006106d7338484611bb6565b600061072e6129c7565b600060606112856110d3565b6001600160a01b031663f94d466861129b6108f7565b6040518263ffffffff1660e01b81526004016112b79190615857565b60006040518083038186803b1580156112cf57600080fd5b505afa1580156112e3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261130b9190810190615177565b509150506113208161131b611a5b565b6125ab565b606061132a612a41565b5090506113378183612abf565b9250505090565b61134c8442111560d1611ba8565b6001600160a01b03871660009081526006602090815260408083205490519092916113a3917f0000000000000000000000000000000000000000000000000000000000000000918c918c918c9188918d910161596c565b60405160208183030381529060405280519060200120905060006113c682612b31565b90506000600182888888604051600081526020016040526040516113ed94939291906159fc565b6020604051602081039080840390855afa15801561140f573d6000803e3d6000fd5b5050604051601f190151915061145190506001600160a01b0382161580159061144957508b6001600160a01b0316826001600160a01b0316145b6101f8611ba8565b6001600160a01b038b16600090815260066020526040902060018501905561147a8b8b8b6118ac565b5050505050505050505050565b60608088611496610ced6110d3565b6114a1610d136108f7565b60606114ab611a5b565b90506114b56106f5565b61156857600060606114ca8d8d8d868b612b4d565b915091506114e36114d9612be3565b83101560cc611ba8565b6114f560006114f0612be3565b612bea565b6115088b611501612be3565b8403612bea565b6115128184612747565b8061151b611c96565b67ffffffffffffffff8111801561153157600080fd5b5060405190808252806020026020018201604052801561155b578160200160208202803683370190505b5095509550505050610d74565b61157288826125ab565b60006060806115878e8e8e8e8e8e8a8f612685565b9250925092506115978c84612bea565b6115a18285612747565b6115ab8185611ccf565b9095509350610d74915050565b60006115c26110d3565b6001600160a01b0316826001600160a01b031614156115e457506000196106db565b6115ee8383612bf4565b90506106db565b6115fd611914565b611605611dcd565b6106f281612c1f565b606061072e611e8a565b80610b2181612c5f565b610aed828414801561163357508183145b6067611ba8565b607f811b1992909216911b1790565b6001600160a01b0382166000908152600284016020526040812054806116ee57505082546040805180820182526001600160a01b03858116808352602080840187815260008781526001808c018452878220965187547fffffffffffffffffffffffff000000000000000000000000000000000000000016961695909517865590519484019490945594820180895590835260028801909452919020919091556107a2565b6000190160009081526001808601602052604082200183905590506107a2565b509392505050565b67ffffffffffffffff811b1992909216911b1790565b77ffffffffffffffffffffffffffffffffffffffffffffffff828116821b90821b198416179392505050565b1c607f1690565b600061176f838311156001611ba8565b50900390565b60006106db670de0b6b3a76400006117938463ffffffff6118138116565b90611861565b60006106db670de0b6b3a76400006117938467ffffffffffffffff611813565b63ffffffff811b1992909216911b1790565b601f811b1992909216911b1790565b60008282016107a28482101583611ba8565b60006001821b1984168284611802576000611805565b60015b60ff16901b17949350505050565b600082820261183784158061183057508385838161182d57fe5b04145b6003611ba8565b806118465760009150506106db565b670de0b6b3a764000060001982015b046001019150506106db565b60006118708215156004611ba8565b8261187d575060006106db565b670de0b6b3a7640000838102906118a09085838161189757fe5b04146005611ba8565b82600182038161185557fe5b6001600160a01b0380841660008181526001602090815260408083209487168084529490915290819020849055517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92590611907908590615857565b60405180910390a3505050565b60006119436000357fffffffff0000000000000000000000000000000000000000000000000000000016611028565b90506106f26119528233612cd8565b610191611ba8565b801561197a5761197561196b611a13565b4210610193611ba8565b61198f565b61198f611985611a37565b42106101a9611ba8565b600780547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168215151790556040517f9e3a5e37224532dea67b89face185703738a228a6e8a23dee546960180d3be64906119eb908390615834565b60405180910390a150565b6000611a00611a37565b42118061072e57505060075460ff161590565b7f000000000000000000000000000000000000000000000000000000000000000090565b7f000000000000000000000000000000000000000000000000000000000000000090565b606080611a666110d3565b6001600160a01b031663f94d4668611a7c6108f7565b6040518263ffffffff1660e01b8152600401611a989190615857565b60006040518083038186803b158015611ab057600080fd5b505afa158015611ac4573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611aec9190810190615177565b505080519091508067ffffffffffffffff81118015611b0a57600080fd5b50604051908082528060200260200182016040528015611b34578160200160208202803683370190505b50925060005b81811015611ba257611b83600b6000858481518110611b5557fe5b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002054612dc1565b848281518110611b8f57fe5b6020908102919091010152600101611b3a565b50505090565b81610b2157610b21816127a8565b611bcd6001600160a01b0384161515610198611ba8565b611be46001600160a01b0383161515610199611ba8565b611bef838383610aed565b6001600160a01b038316600090815260208190526040902054611c1590826101a0612de3565b6001600160a01b038085166000908152602081905260408082209390935590841681522054611c4490826117da565b6001600160a01b0380841660008181526020819052604090819020939093559151908516907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90611907908590615857565b600061072e6001611ca56121b6565b90611758565b600090815260019182016020526040902080549101546001600160a01b0390911691565b60005b611cda611c96565b811015610aed57611d11838281518110611cf057fe5b6020026020010151838381518110611d0457fe5b6020026020010151612563565b838281518110611d1d57fe5b6020908102919091010152600101611cd2565b60007f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000611d9d612df9565b30604051602001611db29594939291906159a0565b60405160208183030381529060405280519060200120905090565b611de0611dd86119f6565b610192611ba8565b565b611df564e8d4a5100082101560cb611ba8565b611e0b67016345785d8a000082111560ca611ba8565b600854611e1a908260c0611716565b6008556040517fa9ba3ffe0b6c366b81232caab38605a0699ad5398d6cce76f91ee809e322dafc906119eb908390615857565b611e5f6002600a541415610190611ba8565b6002600a55565b610b218183146067611ba8565b600081831015611e8357816107a2565b5090919050565b606080611e956110d3565b6001600160a01b031663f94d4668611eab6108f7565b6040518263ffffffff1660e01b8152600401611ec79190615857565b60006040518083038186803b158015611edf57600080fd5b505afa158015611ef3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611f1b9190810190615177565b505080519091508067ffffffffffffffff81118015611f3957600080fd5b50604051908082528060200260200182016040528015611f63578160200160208202803683370190505b5092506000611f70612dfd565b905060005b82811015611fe4576000600b6000868481518110611f8f57fe5b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020549050611fc48184612e73565b868381518110611fd057fe5b602090810291909101015250600101611f75565b5050505090565b600080805b845181101561213657600085828151811061200757fe5b60200260200101519050612027662386f26fc1000082101561012e611ba8565b600085838151811061203557fe5b602002602001015190506121076120c1826001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561207e57600080fd5b505afa158015612092573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120b69190615675565b60129060ff1661175f565b60606121006120cf86611775565b60406120f96120f08f8b815181106120e357fe5b6020026020010151611799565b8b906000611716565b91906117b9565b91906117cb565b6001600160a01b0382166000908152600b602052604090205561212a85836117da565b94505050600101611ff0565b5061214d670de0b6b3a76400008314610134611ba8565b6121696121648760286120f98b60086120f96121b6565b612f0c565b7f0f3631f9dab08169d1db21c6dc5f32536fb2b0a6b9bb5330d71c52132f968be08787878760405161219e9493929190615a79565b60405180910390a150505050505050565b6001600a55565b60085490565b1c60019081161490565b60006121d06108f7565b905060006121dc6110d3565b6001600160a01b031663b05f8e4883866040518363ffffffff1660e01b81526004016122099291906159e5565b60806040518083038186803b15801561222157600080fd5b505afa158015612235573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122599190615635565b6040517f18e736d40000000000000000000000000000000000000000000000000000000081529094506001600160a01b03851693506318e736d492506122a69150859087906004016159cc565b600060405180830381600087803b1580156122c057600080fd5b505af11580156122d4573d6000803e3d6000fd5b5050505050505050565b1c67ffffffffffffffff1690565b600060608060006122fc85612f21565b905061233d612309610af2565b8061231f5750600182600381111561231d57fe5b145b806123355750600382600381111561233357fe5b145b61014a611ba8565b61234689612f37565b61235a8b8a612353611e8a565b8989612f98565b9094509250612367611c96565b67ffffffffffffffff8111801561237d57600080fd5b506040519080825280602002602001820160405280156123a7578160200160208202803683370190505b50915050985098509895505050505050565b3330146124a8576000306001600160a01b03166000366040516123dd92919061574c565b6000604051808303816000865af19150503d806000811461241a576040519150601f19603f3d011682016040523d82523d6000602084013e61241f565b606091505b50509050806000811461242e57fe5b60046000803e6000517fffffffff00000000000000000000000000000000000000000000000000000000167f43adbafb00000000000000000000000000000000000000000000000000000000811461248a573d6000803e3d6000fd5b506020600460003e604060205260243d03602460403e601c3d016000f35b60606124b2611a5b565b90506124be87826125ab565b600060606124d68c8c8c8c8c8c898d8d63ffffffff16565b50915091506124e981848663ffffffff16565b8051601f1982018390526343adbafb7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08301526020027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc82016044820181fd5b60008282026107a284158061183057508385838161182d57fe5b60006125728215156004611ba8565b8261257f575060006106db565b670de0b6b3a7640000838102906125999085838161189757fe5b8281816125a257fe5b049150506106db565b60005b6125b6611c96565b811015610aed576125ed8382815181106125cc57fe5b60200260200101518383815181106125e057fe5b6020026020010151612fdc565b8382815181106125f957fe5b60209081029190910101526001016125ae565b610b218282613008565b61262e6121648260486126276121b6565b91906117ec565b7f5353e2cb47d505ba9b628610daec53fc41f3a4259dab35a757b0f1d5a58bc1c3816040516119eb9190615834565b1c63ffffffff1690565b60006106db63ffffffff61179384670de0b6b3a76400006118138416565b6000606080612692611dcd565b6126b961269d610af2565b80612335575060036126ae86612f21565b600381111561233357fe5b6126cd6126c58b610ff8565b6101b1611ba8565b6126d688612f37565b6126e9886126e2611e8a565b87876130c4565b90935091506126f6611c96565b67ffffffffffffffff8111801561270c57600080fd5b50604051908082528060200260200182016040528015612736578160200160208202803683370190505b509050985098509895505050505050565b60005b612752611c96565b811015610aed5761278983828151811061276857fe5b602002602001015183838151811061277c57fe5b6020026020010151611861565b83828151811061279557fe5b602090810291909101015260010161274a565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b6001600160a01b038216600090815260028401602052604081205461283c81151584611ba8565b6128498560018303613152565b95945050505050565b60006106db61286083613168565b612dc1565b60006107a28383612563565b60008360800151612883610ced6110d3565b61288e610d136108f7565b600061289d8660200151612852565b905060006128ae8760400151612852565b90506000875160018111156128bf57fe5b141561294f5760006128d4886060015161318f565b905060008189606001510390506128f889602001516128f383876131b0565b6131bc565b6060890182905261290988856131b0565b975061291587846131b0565b96506129258960600151856131b0565b60608a015260006129378a8a8a6131ce565b90506129438185612865565b9650505050505061170e565b61295986836131b0565b955061296585826131b0565b94506129758760600151826131b0565b606088015260006129878888886131f6565b9050612993818461320e565b905060006129a08261321a565b9050600082820390506129bb8a602001516128f383886131b0565b50945061170e92505050565b60006129d16110d3565b6001600160a01b031663aaabadc56040518163ffffffff1660e01b815260040160206040518083038186803b158015612a0957600080fd5b505afa158015612a1d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072e919061535e565b60606000612a4d611e8a565b915060009050600082600081518110612a6257fe5b602002602001015190506000600190505b8351811015612ab95781848281518110612a8957fe5b60200260200101511115612ab157809250838181518110612aa657fe5b602002602001015191505b600101612a73565b50509091565b670de0b6b3a764000060005b8351811015612b2157612b17612b10858381518110612ae657fe5b6020026020010151858481518110612afa57fe5b602002602001015161324090919063ffffffff16565b8390612fdc565b9150600101612acb565b506106db60008211610137611ba8565b6000612b3b611d30565b8260405160200161105d92919061575c565b60006060612b59611dcd565b6000612b6484612f21565b9050612b7f6000826003811115612b7757fe5b1460ce611ba8565b6060612b8a8561328f565b9050612b97610a18611c96565b612ba181876125ab565b6060612bab612a41565b5090506000612bba8284612abf565b90506000612bca82610cb4611c96565b60099290925550945090925050505b9550959350505050565b620f424090565b610b2182826132a5565b6001600160a01b03918216600090815260016020908152604080832093909416825291909152205490565b612c306121648260006126276121b6565b7f5a9e84f78f7957cb4ed7478eb0fcad35ee4ecbe2e0f298420b28a3955392573f816040516119eb9190615834565b600281511015612c6e576106f2565b600081600081518110612c7d57fe5b602002602001015190506000600190505b8251811015610aed576000838281518110612ca557fe5b60200260200101519050612cce816001600160a01b0316846001600160a01b0316106065611ba8565b9150600101612c8e565b600073ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1ba1b612cf76110a0565b6001600160a01b031614158015612d125750612d1283613333565b15612d3a57612d1f6110a0565b6001600160a01b0316336001600160a01b03161490506106db565b612d426129c7565b6001600160a01b0316639be2a8848484306040518463ffffffff1660e01b8152600401612d7193929190615860565b60206040518083038186803b158015612d8957600080fd5b505afa158015612d9d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115ee919061525f565b600080612dcf836060613469565b600a0a670de0b6b3a7640000029392505050565b6000612df28484111583611ba8565b5050900390565b4690565b60004281612e096121b6565b90506000612e1882600861265d565b90506000612e2783602861265d565b9050808410612e4457670de0b6b3a76400009450505050506106c7565b818411612e585760009450505050506106c7565b818103828503612e688183612563565b965050505050505090565b600080612e88612e8385836122de565b613470565b90506000612e9a610efa86604061265d565b9050831580612ea857508082145b15612eb5575090506106db565b670de0b6b3a76400008410612ecd5791506106db9050565b80821115612ef0576000612ee385838503612fdc565b90920392506106db915050565b6000612efe85848403612fdc565b9290920192506106db915050565b600854612f1b9082600061172c565b60085550565b6000818060200190518101906106db91906153c8565b60005b612f42611c96565b811015610b2157612f79612f57600c83613152565b838381518110612f6357fe5b602002602001015161175f90919063ffffffff16565b828281518110612f8557fe5b6020908102919091010152600101612f3a565b600060606000612fa784612f21565b90506003816003811115612fb757fe5b1415612fd057612fc688613490565b9250925050612bd9565b612fc687878787613551565b6000828202612ff684158061183057508385838161182d57fe5b670de0b6b3a764000090049392505050565b61301f6001600160a01b038316151561019b611ba8565b61302b82600083610aed565b6001600160a01b03821660009081526020819052604090205461305190826101a1612de3565b6001600160a01b03831660009081526020819052604090205560025461307790826135ca565b6002556040516000906001600160a01b038416907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906130b8908590615857565b60405180910390a35050565b6000606060006130d384612f21565b905060018160038111156130e357fe5b14156130ff576130f5878787876135d8565b9250925050613149565b600281600381111561310d57fe5b141561311e576130f5878786613651565b600381600381111561312c57fe5b141561313c576130f58785613740565b6131476101366127a8565b505b94509492505050565b6000908152600191820160205260409020015490565b6001600160a01b0381166000908152600b6020526040902054610cd9811515610135611ba8565b6000806131a461319d610b25565b8490611813565b90506107a2838261175f565b60006107a28383612fdc565b610b216131c883613772565b82613782565b60006131e36131db610af2565b610147611ba8565b6131ee8484846137e9565b949350505050565b60006132036131db610af2565b6131ee84848461381c565b60006107a28383611861565b60006106db61323961322a610b25565b670de0b6b3a76400009061175f565b8390611861565b60008061324d848461384f565b9050600061326761326083612710611813565b60016117da565b90508082101561327c576000925050506106db565b613286828261175f565b925050506106db565b6060818060200190518101906107a2919061548e565b6132b160008383610aed565b6002546132be90826117da565b6002556001600160a01b0382166000908152602081905260409020546132e490826117da565b6001600160a01b0383166000818152602081905260408082209390935591519091907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906130b8908590615857565b600061335e7f3e56920500000000000000000000000000000000000000000000000000000000611028565b821480613392575061338f7fe01af92c00000000000000000000000000000000000000000000000000000000611028565b82145b806133c457506133c17f5b77155e00000000000000000000000000000000000000000000000000000000611028565b82145b806133f657506133f37f81788e2b00000000000000000000000000000000000000000000000000000000611028565b82145b8061342857506134257f3c9d93b800000000000000000000000000000000000000000000000000000000611028565b82145b8061345a57506134577f7b749c4500000000000000000000000000000000000000000000000000000000611028565b82145b806106db57506106db8261398c565b1c601f1690565b60006106db67ffffffffffffffff61179384670de0b6b3a7640000611813565b6000606061349c611dcd565b6134b36001600160a01b0384163014610151611ba8565b600091506134bf611c96565b67ffffffffffffffff811180156134d557600080fd5b506040519080825280602002602001820160405280156134ff578160200160208202803683370190505b50905060005b61350d611c96565b81101561354b5761351f600c82613152565b82828151811061352b57fe5b6020908102919091010152613543600c8260006139f0565b600101613505565b50915091565b60006060600061356084612f21565b9050600081600381111561357057fe5b1415613581576130f5878786613a08565b600181600381111561358f57fe5b141561359f576130f58785613a73565b60028160038111156135ad57fe5b14156135bf576130f587878787613a98565b6131476101506127a8565b60006107a283836001612de3565b600060608060006135e885613b06565b915091506135fe6135f7611c96565b8351611e66565b61360882876125ab565b600060606136278a8a8661361a6106f5565b613622610b25565b613b29565b9150915061363481613c92565b6136428383101560d0611ba8565b50989197509095505050505050565b6000606060008061366185613cd6565b91509150613679613670611c96565b82106064611ba8565b6000806136bd89848151811061368b57fe5b602002602001015189858151811061369f57fe5b6020026020010151866136b06106f5565b6136b8610b25565b613ced565b915091506136cb8382613782565b60606136d5611c96565b67ffffffffffffffff811180156136eb57600080fd5b50604051908082528060200260200182016040528015613715578160200160208202803683370190505b5090508281858151811061372557fe5b60209081029190910101529399939850929650505050505050565b60006060600061374f84613dc3565b9050606061376586836137606106f5565b613dd9565b9196919550909350505050565b60006106db600c83610135613e8b565b80156137df5760006137b4827f0000000000000000000000000000000000000000000000000000000000000000612fdc565b905060006137c3600c85613152565b90506137dc846137d383856117da565b600c91906139f0565b50505b610b218282610b21565b60006137f3611dcd565b6131ee836138048660200151613eb2565b846138128860400151613eb2565b8860600151613ed6565b6000613826611dcd565b6131ee836138378660200151613eb2565b846138458860400151613eb2565b8860600151613f51565b6000816138655750670de0b6b3a76400006106db565b82613872575060006106db565b61389f7f800000000000000000000000000000000000000000000000000000000000000084106006611ba8565b826138c5770bce5086492111aea88f4bb1ca6bcf584181ea8059f7653284106007611ba8565b826000670c7d713b49da0000831380156138e65750670f43fc2c04ee000083125b1561391d5760006138f684613fc7565b9050670de0b6b3a764000080820784020583670de0b6b3a76400008305020191505061392b565b81613927846140fe565b0290505b670de0b6b3a764000090056139797ffffffffffffffffffffffffffffffffffffffffffffffffdc702bd3a30fc00008212801590613972575068070c1cc73b00c800008213155b6008611ba8565b6139828161449e565b9695505050505050565b60006139b77f38e9922e00000000000000000000000000000000000000000000000000000000611028565b8214806106db57506139e87f50dd6ed900000000000000000000000000000000000000000000000000000000611028565b909114919050565b60009182526001928301602052604090912090910155565b60006060613a14611dcd565b600080613a2085613cd6565b91509150613a2f613670611c96565b6000806136bd898481518110613a4157fe5b6020026020010151898581518110613a5557fe5b602002602001015186613a666106f5565b613a6e610b25565b61496e565b600060606000613a8284613dc3565b905060606137658683613a936106f5565b614a24565b60006060613aa4611dcd565b60606000613ab185613b06565b91509150613ac28251610c6e611c96565b613acc82876125ab565b60006060613aeb8a8a86613ade6106f5565b613ae6610b25565b614ab6565b91509150613afd8383111560cf611ba8565b61364281613c92565b6060600082806020019051810190613b1e91906153e4565b909590945092505050565b6000606080855167ffffffffffffffff81118015613b4657600080fd5b50604051908082528060200260200182016040528015613b70578160200160208202803683370190505b5090506000805b8951811015613c3557613bd08a8281518110613b8f57fe5b6020026020010151610cb98a8481518110613ba657fe5b60200260200101518d8581518110613bba57fe5b60200260200101516117da90919063ffffffff16565b838281518110613bdc57fe5b602002602001018181525050613c2b613c248a8381518110613bfa57fe5b6020026020010151858481518110613c0e57fe5b6020026020010151612fdc90919063ffffffff16565b83906117da565b9150600101613b77565b5060006060613c488b8b8b87878c614bbb565b915091506000670de0b6b3a76400008311613c64576000613c80565b613c80613c7984670de0b6b3a764000061175f565b8a90612fdc565b9c919b50909950505050505050505050565b613c9f8151610c6e611c96565b60005b613caa611c96565b811015610b2157613cce81838381518110613cc157fe5b6020026020010151613782565b600101613ca2565b60008082806020019051810190613b1e9190615458565b60008080613cff8561179381896117da565b9050613d186729a2241af62c0000821115610133611ba8565b6000613d36613d2f670de0b6b3a76400008a611861565b8390614d40565b90506000613d56613d4f83670de0b6b3a764000061175f565b8b90611813565b90506000613d638a614d6c565b90506000613d718383611813565b90506000613d7f848361175f565b90506000613d9f613d98670de0b6b3a76400008c61175f565b8490611861565b83810398509050613db082826117da565b9850505050505050509550959350505050565b6000818060200190518101906107a2919061542b565b60606000613de78484611861565b90506060855167ffffffffffffffff81118015613e0357600080fd5b50604051908082528060200260200182016040528015613e2d578160200160208202803683370190505b50905060005b8651811015613e8157613e6283888381518110613e4c57fe5b602002602001015161181390919063ffffffff16565b828281518110613e6e57fe5b6020908102919091010152600101613e33565b5095945050505050565b600080613e988585614d92565b9050613ea681151584611ba8565b60001901949350505050565b600080613ebd612dfd565b90506000613eca84613168565b90506131ee8183612e73565b6000613ef8613eed87670429d069189e0000612fdc565b831115610130611ba8565b6000613f0487846117da565b90506000613f128883611861565b90506000613f208887612563565b90506000613f2e8383614d40565b9050613f43613f3c82614d6c565b8990612fdc565b9a9950505050505050505050565b6000613f73613f6885670429d069189e0000612fdc565b831115610131611ba8565b6000613f89613f82868561175f565b8690611861565b90506000613f978588611861565b90506000613fa58383614d40565b90506000613fbb82670de0b6b3a764000061175f565b9050613f438a82611813565b670de0b6b3a7640000026000806ec097ce7bc90715b34b9f1000000000808401907fffffffffffffffffffffffffffffffffff3f68318436f8ea4cb460f0000000008501028161401357fe5b05905060006ec097ce7bc90715b34b9f100000000082800205905081806ec097ce7bc90715b34b9f100000000081840205915060038205016ec097ce7bc90715b34b9f100000000082840205915060058205016ec097ce7bc90715b34b9f100000000082840205915060078205016ec097ce7bc90715b34b9f100000000082840205915060098205016ec097ce7bc90715b34b9f1000000000828402059150600b8205016ec097ce7bc90715b34b9f1000000000828402059150600d8205016ec097ce7bc90715b34b9f1000000000828402059150600f826002919005919091010295945050505050565b6000670de0b6b3a764000082121561413b57614131826ec097ce7bc90715b34b9f10000000008161412b57fe5b056140fe565b6000039050610cd9565b60007e1600ef3172e58d2e933ec884fde10064c63b5372d805e203c0000000000000831261418c57770195e54c5dd42177f53a27172fa9ec630262827000000000830592506806f05b59d3b2000000015b73011798004d755d3c8bc8e03204cf44619e00000083126141c4576b1425982cf597cd205cef7380830592506803782dace9d9000000015b606492830292026e01855144814a7ff805980ff0084000831261420c576e01855144814a7ff805980ff008400068056bc75e2d63100000840205925068ad78ebc5ac62000000015b6b02df0ab5a80a22c61ab5a7008312614247576b02df0ab5a80a22c61ab5a70068056bc75e2d6310000084020592506856bc75e2d631000000015b693f1fce3da636ea5cf850831261427e57693f1fce3da636ea5cf85068056bc75e2d631000008402059250682b5e3af16b18800000015b690127fa27722cc06cc5e283126142b557690127fa27722cc06cc5e268056bc75e2d6310000084020592506815af1d78b58c400000015b68280e60114edb805d0383126142ea5768280e60114edb805d0368056bc75e2d631000008402059250680ad78ebc5ac6200000015b680ebc5fb41746121110831261431557680ebc5fb4174612111068056bc75e2d631000009384020592015b6808f00f760a4b2db55d831261434a576808f00f760a4b2db55d68056bc75e2d6310000084020592506802b5e3af16b1880000015b6806f5f1775788937937831261437f576806f5f177578893793768056bc75e2d63100000840205925068015af1d78b58c40000015b6806248f33704b28660383126143b3576806248f33704b28660368056bc75e2d63100000840205925067ad78ebc5ac620000015b6805c548670b9510e7ac83126143e7576805c548670b9510e7ac68056bc75e2d6310000084020592506756bc75e2d6310000015b600068056bc75e2d63100000840168056bc75e2d63100000808603028161440a57fe5b059050600068056bc75e2d63100000828002059050818068056bc75e2d63100000818402059150600382050168056bc75e2d63100000828402059150600582050168056bc75e2d63100000828402059150600782050168056bc75e2d63100000828402059150600982050168056bc75e2d63100000828402059150600b820501600202606485820105979650505050505050565b60006144e37ffffffffffffffffffffffffffffffffffffffffffffffffdc702bd3a30fc000083121580156144dc575068070c1cc73b00c800008313155b6009611ba8565b6000821215614517576144f88260000361449e565b6ec097ce7bc90715b34b9f10000000008161450f57fe5b059050610cd9565b60006806f05b59d3b2000000831261456d57507ffffffffffffffffffffffffffffffffffffffffffffffff90fa4a62c4e00000090910190770195e54c5dd42177f53a27172fa9ec6302628270000000006145b9565b6803782dace9d900000083126145b557507ffffffffffffffffffffffffffffffffffffffffffffffffc87d2531627000000909101906b1425982cf597cd205cef73806145b9565b5060015b6064929092029168056bc75e2d6310000068ad78ebc5ac62000000841261461f577fffffffffffffffffffffffffffffffffffffffffffffff5287143a539e0000009093019268056bc75e2d631000006e01855144814a7ff805980ff008400082020590505b6856bc75e2d6310000008412614671577fffffffffffffffffffffffffffffffffffffffffffffffa9438a1d29cf0000009093019268056bc75e2d631000006b02df0ab5a80a22c61ab5a70082020590505b682b5e3af16b1880000084126146c1577fffffffffffffffffffffffffffffffffffffffffffffffd4a1c50e94e78000009093019268056bc75e2d63100000693f1fce3da636ea5cf85082020590505b6815af1d78b58c4000008412614711577fffffffffffffffffffffffffffffffffffffffffffffffea50e2874a73c000009093019268056bc75e2d63100000690127fa27722cc06cc5e282020590505b680ad78ebc5ac62000008412614760577ffffffffffffffffffffffffffffffffffffffffffffffff5287143a539e000009093019268056bc75e2d6310000068280e60114edb805d0382020590505b68056bc75e2d6310000084126147af577ffffffffffffffffffffffffffffffffffffffffffffffffa9438a1d29cf000009093019268056bc75e2d63100000680ebc5fb4174612111082020590505b6802b5e3af16b188000084126147fe577ffffffffffffffffffffffffffffffffffffffffffffffffd4a1c50e94e7800009093019268056bc75e2d631000006808f00f760a4b2db55d82020590505b68015af1d78b58c40000841261484d577ffffffffffffffffffffffffffffffffffffffffffffffffea50e2874a73c00009093019268056bc75e2d631000006806f5f177578893793782020590505b68056bc75e2d631000008481019085906002908280020505918201919050600368056bc75e2d631000008783020505918201919050600468056bc75e2d631000008783020505918201919050600568056bc75e2d631000008783020505918201919050600668056bc75e2d631000008783020505918201919050600768056bc75e2d631000008783020505918201919050600868056bc75e2d631000008783020505918201919050600968056bc75e2d631000008783020505918201919050600a68056bc75e2d631000008783020505918201919050600b68056bc75e2d631000008783020505918201919050600c68056bc75e2d631000008783020505918201919050606468056bc75e2d63100000848402058502059695505050505050565b6000808061498085611793818961175f565b90506149996709b6e64a8ec60000821015610132611ba8565b60006149b0613d2f670de0b6b3a76400008a612563565b905060006149c76149c083614d6c565b8b90612fdc565b905060006149d48a614d6c565b905060006149e28383611813565b905060006149f0848361175f565b90506149fc828a611813565b9650614a12614a0b838961175f565b82906117da565b97505050505050509550959350505050565b60606000614a328484612563565b90506060855167ffffffffffffffff81118015614a4e57600080fd5b50604051908082528060200260200182016040528015614a78578160200160208202803683370190505b50905060005b8651811015613e8157614a9783888381518110613c0e57fe5b828281518110614aa357fe5b6020908102919091010152600101614a7e565b6000606080855167ffffffffffffffff81118015614ad357600080fd5b50604051908082528060200260200182016040528015614afd578160200160208202803683370190505b5090506000805b8951811015614b8f57614b478a8281518110614b1c57fe5b60200260200101516117938a8481518110614b3357fe5b60200260200101518d8581518110612f6357fe5b838281518110614b5357fe5b602002602001018181525050614b85613c248a8381518110614b7157fe5b6020026020010151858481518110613e4c57fe5b9150600101614b04565b5060006060614ba28b8b8b87878c614db1565b915091506000613c80614bb484614d6c565b8a90611813565b60006060855167ffffffffffffffff81118015614bd757600080fd5b50604051908082528060200260200182016040528015614c01578160200160208202803683370190505b509050670de0b6b3a7640000915060005b8851811015614d3457600085878381518110614c2a57fe5b60200260200101511115614cb6576000614c5b614c4f88670de0b6b3a764000061175f565b8c8581518110613c0e57fe5b90506000614c6f828b8681518110612f6357fe5b90506000614c7d8289611813565b9050614c93614c8c838361175f565b84906117da565b935080868681518110614ca257fe5b602002602001018181525050505050614ccd565b878281518110614cc257fe5b602002602001015190505b6000614cf68b8481518110614cde57fe5b6020026020010151610cb9848e8781518110613bba57fe5b9050614d28614d218b8581518110614d0a57fe5b60200260200101518361324090919063ffffffff16565b8690612fdc565b94505050600101614c12565b50965096945050505050565b600080614d4d848461384f565b90506000614d6061326083612710611813565b905061284982826117da565b6000670de0b6b3a76400008210614d845760006106db565b50670de0b6b3a76400000390565b6001600160a01b03166000908152600291909101602052604090205490565b60006060855167ffffffffffffffff81118015614dcd57600080fd5b50604051908082528060200260200182016040528015614df7578160200160208202803683370190505b509050670de0b6b3a7640000915060005b8851811015614d34576000868281518110614e1f57fe5b6020026020010151861115614e99576000614e3c614c4f88614d6c565b90506000614e50828b8681518110612f6357fe5b90506000614e69613239670de0b6b3a76400008a61175f565b9050818103868681518110614e7a57fe5b6020908102919091010152614e8f83826117da565b9350505050614eb0565b878281518110614ea557fe5b602002602001015190505b6000614ed98b8481518110614ec157fe5b6020026020010151610cb9848e8781518110612f6357fe5b9050614eed614d218b8581518110614d0a57fe5b94505050600101614e08565b80356106db81615b16565b600082601f830112614f14578081fd5b8135614f27614f2282615aea565b615ac3565b818152915060208083019084810181840286018201871015614f4857600080fd5b60005b84811015614f6757813584529282019290820190600101614f4b565b505050505092915050565b600082601f830112614f82578081fd5b8151614f90614f2282615aea565b818152915060208083019084810181840286018201871015614fb157600080fd5b60005b84811015614f6757815184529282019290820190600101614fb4565b600082601f830112614fe0578081fd5b813567ffffffffffffffff811115614ff6578182fd5b6150096020601f19601f84011601615ac3565b915080825283602082850101111561502057600080fd5b8060208401602084013760009082016020015292915050565b8035600281106106db57600080fd5b600060208284031215615059578081fd5b81356107a281615b16565b60008060408385031215615076578081fd5b823561508181615b16565b9150602083013561509181615b16565b809150509250929050565b6000806000606084860312156150b0578081fd5b83356150bb81615b16565b925060208401356150cb81615b16565b929592945050506040919091013590565b600080600080600080600060e0888a0312156150f6578283fd5b873561510181615b16565b9650602088013561511181615b16565b95506040880135945060608801359350608088013561512f81615b46565b9699959850939692959460a0840135945060c09093013592915050565b6000806040838503121561515e578182fd5b823561516981615b16565b946020939093013593505050565b60008060006060848603121561518b578081fd5b835167ffffffffffffffff808211156151a2578283fd5b818601915086601f8301126151b5578283fd5b81516151c3614f2282615aea565b80828252602080830192508086018b8283870289010111156151e3578788fd5b8796505b8487101561520e5780516151fa81615b16565b8452600196909601959281019281016151e7565b508901519097509350505080821115615225578283fd5b5061523286828701614f72565b925050604084015190509250925092565b600060208284031215615254578081fd5b81356107a281615b2b565b600060208284031215615270578081fd5b81516107a281615b2b565b600080600080600080600060e0888a031215615295578081fd5b8735965060208801356152a781615b16565b955060408801356152b781615b16565b9450606088013567ffffffffffffffff808211156152d3578283fd5b6152df8b838c01614f04565b955060808a0135945060a08a0135935060c08a0135915080821115615302578283fd5b5061530f8a828b01614fd0565b91505092959891949750929550565b60006020828403121561532f578081fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146107a2578182fd5b60006020828403121561536f578081fd5b81516107a281615b16565b6000806040838503121561538c578182fd5b823561539781615b16565b9150602083013567ffffffffffffffff8111156153b2578182fd5b6153be85828601614fd0565b9150509250929050565b6000602082840312156153d9578081fd5b81516107a281615b39565b6000806000606084860312156153f8578081fd5b835161540381615b39565b602085015190935067ffffffffffffffff81111561541f578182fd5b61523286828701614f72565b6000806040838503121561543d578182fd5b825161544881615b39565b6020939093015192949293505050565b60008060006060848603121561546c578081fd5b835161547781615b39565b602085015160409095015190969495509392505050565b600080604083850312156154a0578182fd5b82516154ab81615b39565b602084015190925067ffffffffffffffff8111156154c7578182fd5b6153be85828601614f72565b6000806000606084860312156154e7578081fd5b833567ffffffffffffffff808211156154fe578283fd5b8186019150610120808389031215615514578384fd5b61551d81615ac3565b90506155298884615039565b81526155388860208501614ef9565b602082015261554a8860408501614ef9565b6040820152606083013560608201526080830135608082015260a083013560a082015261557a8860c08501614ef9565b60c082015261558c8860e08501614ef9565b60e082015261010080840135838111156155a4578586fd5b6155b08a828701614fd0565b9183019190915250976020870135975060409096013595945050505050565b6000602082840312156155e0578081fd5b5035919050565b6000806000606084860312156155fb578081fd5b8335925060208401359150604084013567ffffffffffffffff81111561561f578182fd5b61562b86828701614f04565b9150509250925092565b6000806000806080858703121561564a578182fd5b845193506020850151925060408501519150606085015161566a81615b16565b939692955090935050565b600060208284031215615686578081fd5b81516107a281615b46565b6000815180845260208085019450808401835b838110156156c0578151875295820195908201906001016156a4565b509495945050505050565b15159052565b60008151808452815b818110156156f6576020818501810151868301820152016156da565b818111156157075782602083870101525b50601f01601f19169290920160200192915050565b9182527fffffffff0000000000000000000000000000000000000000000000000000000016602082015260240190565b6000828483379101908152919050565b7f190100000000000000000000000000000000000000000000000000000000000081526002810192909252602282015260420190565b6001600160a01b0391909116815260200190565b604080825283519082018190526000906020906060840190828701845b828110156157e85781516001600160a01b0316845292840192908401906001016157c3565b505050838103828501526139828186615691565b6000602082526107a26020830184615691565b6000604082526158226040830185615691565b82810360208401526128498185615691565b901515815260200190565b92151583526020830191909152604082015260600190565b90815260200190565b9283526001600160a01b03918216602084015216604082015260600190565b600085825260206001600160a01b038087168285015280861660408501525060806060840152610100830184516080808601528181518084526101208701915084830193508592505b808310156158f0576158da8451615b0a565b82529284019260019290920191908401906158c8565b508387015193507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff809250828682030160a087015261592e8185615691565b935050506040850151818584030160c086015261594b83826156d1565b92505050606084015161596160e08501826156cb565b509695505050505050565b9586526001600160a01b0394851660208701529290931660408501526060840152608083019190915260a082015260c00190565b9485526020850193909352604084019190915260608301526001600160a01b0316608082015260a00190565b6000838252604060208301526131ee60408301846156d1565b9182526001600160a01b0316602082015260400190565b93845260ff9290921660208401526040830152606082015260800190565b6020810160048310615a2857fe5b91905290565b6000602082526107a260208301846156d1565b6000838252604060208301526131ee6040830184615691565b6000848252836020830152606060408301526128496060830184615691565b600085825284602083015260806040830152615a986080830185615691565b8281036060840152615aaa8185615691565b979650505050505050565b60ff91909116815260200190565b60405181810167ffffffffffffffff81118282101715615ae257600080fd5b604052919050565b600067ffffffffffffffff821115615b00578081fd5b5060209081020190565b6001600160a01b031690565b6001600160a01b03811681146106f257600080fd5b80151581146106f257600080fd5b600481106106f257600080fd5b60ff811681146106f257600080fdfea2646970667358221220c4586bce9bcbc9930712a4c9bbbd42fc2c217da334271ddc364040503079f51c64736f6c63430007010033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100715760003560e01c80636634b753116100505780636634b753146100c05780638d928af8146100e0578063a7c671eb146100f557610071565b8062c194db14610076578063174481fa146100945780632da47c40146100aa575b600080fd5b61007e610108565b60405161008b9190610a73565b60405180910390f35b61009c610127565b60405161008b929190610a41565b6100b261016d565b60405161008b929190610bc2565b6100d36100ce3660046107e6565b6101d7565b60405161008b9190610a68565b6100e8610202565b60405161008b9190610a20565b6100e8610103366004610802565b610226565b60606101226040518060200160405280600081525061035d565b905090565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000009091565b600080427f00000000000000000000000000000000000000000000000000000000000000008110156101c957807f000000000000000000000000000000000000000000000000000000000000000003925062278d0091506101d2565b60009250600091505b509091565b73ffffffffffffffffffffffffffffffffffffffff1660009081526020819052604090205460ff1690565b7f000000000000000000000000000000000000000000000000000000000000000090565b600080600061023361016d565b915091506102ed604051806101a0016040528061024e610202565b73ffffffffffffffffffffffffffffffffffffffff1681526020018f81526020018e81526020018d81526020018c81526020018b81526020018a81526020018481526020018381526020018973ffffffffffffffffffffffffffffffffffffffff16815260200188151581526020018715158152602001868152506040516020016102d99190610a86565b604051602081830303815290604052610436565b9d9c50505050505050505050505050565b80517f602038038060206000396000f3fefefefefefefefefefefefefefefefefefefe808352600091602081018484f0908452915061035773ffffffffffffffffffffffffffffffffffffffff831615156101ac6104c1565b50919050565b8051604080517f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000818101858101848101602090810190965280855293957f00000000000000000000000000000000000000000000000000000000000000009592947f000000000000000000000000000000000000000000000000000000000000000094938801866000828a3c846000888301883c50602089810190898501016104288183866104d3565b505050505050505050919050565b6000806104428361054d565b73ffffffffffffffffffffffffffffffffffffffff811660008181526020819052604080822080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790555192935090917f83a48fbcfc991335314e74d0496aab6a1987e992ddc85dddbcc4d6dd6ef2e9fc9190a292915050565b816104cf576104cf81610595565b5050565b5b602081106105115781518352602092830192909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0016104d4565b905182516020929092036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169116179052565b6000606061055a8361035d565b905060008151602083016000f0905073ffffffffffffffffffffffffffffffffffffffff811661058e573d6000803e3d6000fd5b9392505050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b803561060d81610c17565b92915050565b600082601f830112610623578081fd5b813561063661063182610bf7565b610bd0565b81815291506020808301908481018184028601820187101561065757600080fd5b60005b8481101561067f57813561066d81610c17565b8452928201929082019060010161065a565b505050505092915050565b600082601f83011261069a578081fd5b81356106a861063182610bf7565b8181529150602080830190848101818402860182018710156106c957600080fd5b60005b8481101561067f5781356106df81610c17565b845292820192908201906001016106cc565b600082601f830112610701578081fd5b813561070f61063182610bf7565b81815291506020808301908481018184028601820187101561073057600080fd5b60005b8481101561067f57813584529282019290820190600101610733565b8035801515811461060d57600080fd5b600082601f83011261076f578081fd5b813567ffffffffffffffff811115610785578182fd5b6107b660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610bd0565b91508082528360208285010111156107cd57600080fd5b8060208401602084013760009082016020015292915050565b6000602082840312156107f7578081fd5b813561058e81610c17565b6000806000806000806000806000806101408b8d031215610821578586fd5b8a3567ffffffffffffffff80821115610838578788fd5b6108448e838f0161075f565b9b5060208d0135915080821115610859578788fd5b6108658e838f0161075f565b9a5060408d013591508082111561087a578788fd5b6108868e838f0161068a565b995060608d013591508082111561089b578788fd5b6108a78e838f016106f1565b985060808d01359150808211156108bc578788fd5b506108c98d828e01610613565b96505060a08b013594506108e08c60c08d01610602565b93506108ef8c60e08d0161074f565b92506108ff8c6101008d0161074f565b91506101208b013590509295989b9194979a5092959850565b73ffffffffffffffffffffffffffffffffffffffff169052565b6000815180845260208085019450808401835b8381101561097757815173ffffffffffffffffffffffffffffffffffffffff1687529582019590820190600101610945565b509495945050505050565b6000815180845260208085019450808401835b8381101561097757815187529582019590820190600101610995565b15159052565b60008151808452815b818110156109dc576020818501810151868301820152016109c0565b818111156109ed5782602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff92831681529116602082015260400190565b901515815260200190565b60006020825261058e60208301846109b7565b600060208252610a9a602083018451610918565b60208301516101a0806040850152610ab66101c08501836109b7565b915060408501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe080868503016060870152610af284836109b7565b93506060870151915080868503016080870152610b0f8483610932565b935060808701519150808685030160a0870152610b2c8483610982565b935060a08701519150808685030160c087015250610b4a8382610932565b92505060c085015160e085015260e0850151610100818187015280870151915050610120818187015280870151915050610140610b8981870183610918565b8601519050610160610b9d868201836109b1565b8601519050610180610bb1868201836109b1565b959095015193019290925250919050565b918252602082015260400190565b60405181810167ffffffffffffffff81118282101715610bef57600080fd5b604052919050565b600067ffffffffffffffff821115610c0d578081fd5b5060209081020190565b73ffffffffffffffffffffffffffffffffffffffff81168114610c3957600080fd5b5056fea264697066735822122019d43b0379102538042b144e1f9d289867affe41ec2bd8deb1d36ae9a389efeb64736f6c63430007010033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "create(string,string,address[],uint256[],address[],uint256,address,bool,bool,uint256)": {
        "params": {
          "assetManagers": "Addresses of asset managers.",
          "managementSwapFeePercentage": "Management swap fee percentage.",
          "mustAllowlistLPs": "If true, only listed addresses can join the pool.",
          "name": "Pool Token name.",
          "owner": "Pool controller.",
          "swapEnabledOnStart": "Swap enabled states on start.",
          "swapFeePercentage": "Swap fee percentage.",
          "symbol": "Pool Token symbol.",
          "tokens": "Addresses of asset tokens.",
          "weights": "Initial weights of asset tokens."
        }
      },
      "getCreationCode()": {
        "details": "Returns the creation code of the contract this factory creates."
      },
      "getCreationCodeContracts()": {
        "details": "Returns the two addresses where the creation code of the contract crated by this factory is stored."
      },
      "getPauseConfiguration()": {
        "details": "Returns the current `TemporarilyPausable` configuration that will be applied to Pools created by this factory. `pauseWindowDuration` will decrease over time until it reaches zero, at which point both it and `bufferPeriodDuration` will be zero forever, meaning deployed Pools will not be pausable."
      },
      "getVault()": {
        "details": "Returns the Vault's address."
      },
      "isPoolFromFactory(address)": {
        "details": "Returns true if `pool` was created by this factory."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "create(string,string,address[],uint256[],address[],uint256,address,bool,bool,uint256)": {
        "notice": "Deploys a New Balancer ManagedPool."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2680,
        "contract": "contracts/MammonPoolFactoryV1.sol:MammonPoolFactoryV1",
        "label": "_isPoolFromFactory",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}